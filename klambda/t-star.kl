"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.typecheck (V3386 V3387) (let Curry (shen.curry V3386) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V3387)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V3389) (cond ((and (cons? V3389) (shen.special? (hd V3389))) (cons (hd V3389) (map (lambda Y (shen.curry Y)) (tl V3389)))) ((and (cons? V3389) (and (cons? (tl V3389)) (shen.extraspecial? (hd V3389)))) V3389) ((and (cons? V3389) (and (= type (hd V3389)) (and (cons? (tl V3389)) (and (cons? (tl (tl V3389))) (= () (tl (tl (tl V3389)))))))) (cons type (cons (shen.curry (hd (tl V3389))) (tl (tl V3389))))) ((and (cons? V3389) (and (cons? (tl V3389)) (cons? (tl (tl V3389))))) (shen.curry (cons (cons (hd V3389) (cons (hd (tl V3389)) ())) (tl (tl V3389))))) ((and (cons? V3389) (and (cons? (tl V3389)) (= () (tl (tl V3389))))) (cons (shen.curry (hd V3389)) (cons (shen.curry (hd (tl V3389))) ()))) (true V3389)))

(defun shen.special? (V3391) (element? V3391 (value shen.*special*)))

(defun shen.extraspecial? (V3393) (element? V3393 (value shen.*extraspecial*)))

(defun shen.t* (V3398 V3399 V3400 V3401) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V3400) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V3400 (freeze (bind Error (shen.errormaxinfs) V3400 V3401))))) (if (= Case false) (let Case (let V3378 (shen.lazyderef V3398 V3400) (if (= fail V3378) (do (shen.incinfs) (cut Throwcontrol V3400 (freeze (shen.prolog-failure V3400 V3401)))) false)) (if (= Case false) (let Case (let V3379 (shen.lazyderef V3398 V3400) (if (cons? V3379) (let X (hd V3379) (let V3380 (shen.lazyderef (tl V3379) V3400) (if (cons? V3380) (let V3381 (shen.lazyderef (hd V3380) V3400) (if (= : V3381) (let V3382 (shen.lazyderef (tl V3380) V3400) (if (cons? V3382) (let A (hd V3382) (let V3383 (shen.lazyderef (tl V3382) V3400) (if (= () V3383) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V3400 (freeze (cut Throwcontrol V3400 (freeze (shen.th* X A V3399 V3400 V3401)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V3400) (do (shen.incinfs) (shen.show V3398 V3399 V3400 (freeze (bind Datatypes (value shen.*datatypes*) V3400 (freeze (shen.udefs* V3398 V3399 Datatypes V3400 V3401))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V3407) (cond ((= + V3407) (set shen.*shen-type-theory-enabled?* true)) ((= - V3407) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V3418 V3419) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V3425 V3426 V3427 V3428 V3429) (let Case (let V3374 (shen.lazyderef V3427 V3428) (if (cons? V3374) (let D (hd V3374) (do (shen.incinfs) (call (cons D (cons V3425 (cons V3426 ()))) V3428 V3429))) false)) (if (= Case false) (let V3375 (shen.lazyderef V3427 V3428) (if (cons? V3375) (let Ds (tl V3375) (do (shen.incinfs) (shen.udefs* V3425 V3426 Ds V3428 V3429))) false)) Case)))

(defun shen.th* (V3435 V3436 V3437 V3438 V3439) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V3435 (cons : (cons V3436 ()))) V3437 V3438 (freeze (fwhen false V3438 V3439)))) (if (= Case false) (let Case (let F (shen.newpv V3438) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V3435 V3438)) V3438 (freeze (bind F (shen.sigf (shen.lazyderef V3435 V3438)) V3438 (freeze (call (cons F (cons V3436 ())) V3438 V3439))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V3435 V3436 V3438 V3439)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V3435 V3436 V3437 V3438 V3439)) (if (= Case false) (let Case (let V3270 (shen.lazyderef V3435 V3438) (if (cons? V3270) (let F (hd V3270) (let V3271 (shen.lazyderef (tl V3270) V3438) (if (= () V3271) (do (shen.incinfs) (shen.th* F (cons --> (cons V3436 ())) V3437 V3438 V3439)) false))) false)) (if (= Case false) (let Case (let V3272 (shen.lazyderef V3435 V3438) (if (cons? V3272) (let F (hd V3272) (let V3273 (shen.lazyderef (tl V3272) V3438) (if (cons? V3273) (let X (hd V3273) (let V3274 (shen.lazyderef (tl V3273) V3438) (if (= () V3274) (let B (shen.newpv V3438) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V3436 ()))) V3437 V3438 (freeze (shen.th* X B V3437 V3438 V3439))))) false))) false))) false)) (if (= Case false) (let Case (let V3275 (shen.lazyderef V3435 V3438) (if (cons? V3275) (let V3276 (shen.lazyderef (hd V3275) V3438) (if (= cons V3276) (let V3277 (shen.lazyderef (tl V3275) V3438) (if (cons? V3277) (let X (hd V3277) (let V3278 (shen.lazyderef (tl V3277) V3438) (if (cons? V3278) (let Y (hd V3278) (let V3279 (shen.lazyderef (tl V3278) V3438) (if (= () V3279) (let V3280 (shen.lazyderef V3436 V3438) (if (cons? V3280) (let V3281 (shen.lazyderef (hd V3280) V3438) (if (= list V3281) (let V3282 (shen.lazyderef (tl V3280) V3438) (if (cons? V3282) (let A (hd V3282) (let V3283 (shen.lazyderef (tl V3282) V3438) (if (= () V3283) (do (shen.incinfs) (shen.th* X A V3437 V3438 (freeze (shen.th* Y (cons list (cons A ())) V3437 V3438 V3439)))) (if (shen.pvar? V3283) (do (shen.bindv V3283 () V3438) (let Result (do (shen.incinfs) (shen.th* X A V3437 V3438 (freeze (shen.th* Y (cons list (cons A ())) V3437 V3438 V3439)))) (do (shen.unbindv V3283 V3438) Result))) false)))) (if (shen.pvar? V3282) (let A (shen.newpv V3438) (do (shen.bindv V3282 (cons A ()) V3438) (let Result (do (shen.incinfs) (shen.th* X A V3437 V3438 (freeze (shen.th* Y (cons list (cons A ())) V3437 V3438 V3439)))) (do (shen.unbindv V3282 V3438) Result)))) false))) (if (shen.pvar? V3281) (do (shen.bindv V3281 list V3438) (let Result (let V3284 (shen.lazyderef (tl V3280) V3438) (if (cons? V3284) (let A (hd V3284) (let V3285 (shen.lazyderef (tl V3284) V3438) (if (= () V3285) (do (shen.incinfs) (shen.th* X A V3437 V3438 (freeze (shen.th* Y (cons list (cons A ())) V3437 V3438 V3439)))) (if (shen.pvar? V3285) (do (shen.bindv V3285 () V3438) (let Result (do (shen.incinfs) (shen.th* X A V3437 V3438 (freeze (shen.th* Y (cons list (cons A ())) V3437 V3438 V3439)))) (do (shen.unbindv V3285 V3438) Result))) false)))) (if (shen.pvar? V3284) (let A (shen.newpv V3438) (do (shen.bindv V3284 (cons A ()) V3438) (let Result (do (shen.incinfs) (shen.th* X A V3437 V3438 (freeze (shen.th* Y (cons list (cons A ())) V3437 V3438 V3439)))) (do (shen.unbindv V3284 V3438) Result)))) false))) (do (shen.unbindv V3281 V3438) Result))) false))) (if (shen.pvar? V3280) (let A (shen.newpv V3438) (do (shen.bindv V3280 (cons list (cons A ())) V3438) (let Result (do (shen.incinfs) (shen.th* X A V3437 V3438 (freeze (shen.th* Y (cons list (cons A ())) V3437 V3438 V3439)))) (do (shen.unbindv V3280 V3438) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3286 (shen.lazyderef V3435 V3438) (if (cons? V3286) (let V3287 (shen.lazyderef (hd V3286) V3438) (if (= @p V3287) (let V3288 (shen.lazyderef (tl V3286) V3438) (if (cons? V3288) (let X (hd V3288) (let V3289 (shen.lazyderef (tl V3288) V3438) (if (cons? V3289) (let Y (hd V3289) (let V3290 (shen.lazyderef (tl V3289) V3438) (if (= () V3290) (let V3291 (shen.lazyderef V3436 V3438) (if (cons? V3291) (let A (hd V3291) (let V3292 (shen.lazyderef (tl V3291) V3438) (if (cons? V3292) (let V3293 (shen.lazyderef (hd V3292) V3438) (if (= * V3293) (let V3294 (shen.lazyderef (tl V3292) V3438) (if (cons? V3294) (let B (hd V3294) (let V3295 (shen.lazyderef (tl V3294) V3438) (if (= () V3295) (do (shen.incinfs) (shen.th* X A V3437 V3438 (freeze (shen.th* Y B V3437 V3438 V3439)))) (if (shen.pvar? V3295) (do (shen.bindv V3295 () V3438) (let Result (do (shen.incinfs) (shen.th* X A V3437 V3438 (freeze (shen.th* Y B V3437 V3438 V3439)))) (do (shen.unbindv V3295 V3438) Result))) false)))) (if (shen.pvar? V3294) (let B (shen.newpv V3438) (do (shen.bindv V3294 (cons B ()) V3438) (let Result (do (shen.incinfs) (shen.th* X A V3437 V3438 (freeze (shen.th* Y B V3437 V3438 V3439)))) (do (shen.unbindv V3294 V3438) Result)))) false))) (if (shen.pvar? V3293) (do (shen.bindv V3293 * V3438) (let Result (let V3296 (shen.lazyderef (tl V3292) V3438) (if (cons? V3296) (let B (hd V3296) (let V3297 (shen.lazyderef (tl V3296) V3438) (if (= () V3297) (do (shen.incinfs) (shen.th* X A V3437 V3438 (freeze (shen.th* Y B V3437 V3438 V3439)))) (if (shen.pvar? V3297) (do (shen.bindv V3297 () V3438) (let Result (do (shen.incinfs) (shen.th* X A V3437 V3438 (freeze (shen.th* Y B V3437 V3438 V3439)))) (do (shen.unbindv V3297 V3438) Result))) false)))) (if (shen.pvar? V3296) (let B (shen.newpv V3438) (do (shen.bindv V3296 (cons B ()) V3438) (let Result (do (shen.incinfs) (shen.th* X A V3437 V3438 (freeze (shen.th* Y B V3437 V3438 V3439)))) (do (shen.unbindv V3296 V3438) Result)))) false))) (do (shen.unbindv V3293 V3438) Result))) false))) (if (shen.pvar? V3292) (let B (shen.newpv V3438) (do (shen.bindv V3292 (cons * (cons B ())) V3438) (let Result (do (shen.incinfs) (shen.th* X A V3437 V3438 (freeze (shen.th* Y B V3437 V3438 V3439)))) (do (shen.unbindv V3292 V3438) Result)))) false)))) (if (shen.pvar? V3291) (let A (shen.newpv V3438) (let B (shen.newpv V3438) (do (shen.bindv V3291 (cons A (cons * (cons B ()))) V3438) (let Result (do (shen.incinfs) (shen.th* X A V3437 V3438 (freeze (shen.th* Y B V3437 V3438 V3439)))) (do (shen.unbindv V3291 V3438) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3298 (shen.lazyderef V3435 V3438) (if (cons? V3298) (let V3299 (shen.lazyderef (hd V3298) V3438) (if (= @v V3299) (let V3300 (shen.lazyderef (tl V3298) V3438) (if (cons? V3300) (let X (hd V3300) (let V3301 (shen.lazyderef (tl V3300) V3438) (if (cons? V3301) (let Y (hd V3301) (let V3302 (shen.lazyderef (tl V3301) V3438) (if (= () V3302) (let V3303 (shen.lazyderef V3436 V3438) (if (cons? V3303) (let V3304 (shen.lazyderef (hd V3303) V3438) (if (= vector V3304) (let V3305 (shen.lazyderef (tl V3303) V3438) (if (cons? V3305) (let A (hd V3305) (let V3306 (shen.lazyderef (tl V3305) V3438) (if (= () V3306) (do (shen.incinfs) (shen.th* X A V3437 V3438 (freeze (shen.th* Y (cons vector (cons A ())) V3437 V3438 V3439)))) (if (shen.pvar? V3306) (do (shen.bindv V3306 () V3438) (let Result (do (shen.incinfs) (shen.th* X A V3437 V3438 (freeze (shen.th* Y (cons vector (cons A ())) V3437 V3438 V3439)))) (do (shen.unbindv V3306 V3438) Result))) false)))) (if (shen.pvar? V3305) (let A (shen.newpv V3438) (do (shen.bindv V3305 (cons A ()) V3438) (let Result (do (shen.incinfs) (shen.th* X A V3437 V3438 (freeze (shen.th* Y (cons vector (cons A ())) V3437 V3438 V3439)))) (do (shen.unbindv V3305 V3438) Result)))) false))) (if (shen.pvar? V3304) (do (shen.bindv V3304 vector V3438) (let Result (let V3307 (shen.lazyderef (tl V3303) V3438) (if (cons? V3307) (let A (hd V3307) (let V3308 (shen.lazyderef (tl V3307) V3438) (if (= () V3308) (do (shen.incinfs) (shen.th* X A V3437 V3438 (freeze (shen.th* Y (cons vector (cons A ())) V3437 V3438 V3439)))) (if (shen.pvar? V3308) (do (shen.bindv V3308 () V3438) (let Result (do (shen.incinfs) (shen.th* X A V3437 V3438 (freeze (shen.th* Y (cons vector (cons A ())) V3437 V3438 V3439)))) (do (shen.unbindv V3308 V3438) Result))) false)))) (if (shen.pvar? V3307) (let A (shen.newpv V3438) (do (shen.bindv V3307 (cons A ()) V3438) (let Result (do (shen.incinfs) (shen.th* X A V3437 V3438 (freeze (shen.th* Y (cons vector (cons A ())) V3437 V3438 V3439)))) (do (shen.unbindv V3307 V3438) Result)))) false))) (do (shen.unbindv V3304 V3438) Result))) false))) (if (shen.pvar? V3303) (let A (shen.newpv V3438) (do (shen.bindv V3303 (cons vector (cons A ())) V3438) (let Result (do (shen.incinfs) (shen.th* X A V3437 V3438 (freeze (shen.th* Y (cons vector (cons A ())) V3437 V3438 V3439)))) (do (shen.unbindv V3303 V3438) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3309 (shen.lazyderef V3435 V3438) (if (cons? V3309) (let V3310 (shen.lazyderef (hd V3309) V3438) (if (= @s V3310) (let V3311 (shen.lazyderef (tl V3309) V3438) (if (cons? V3311) (let X (hd V3311) (let V3312 (shen.lazyderef (tl V3311) V3438) (if (cons? V3312) (let Y (hd V3312) (let V3313 (shen.lazyderef (tl V3312) V3438) (if (= () V3313) (let V3314 (shen.lazyderef V3436 V3438) (if (= string V3314) (do (shen.incinfs) (shen.th* X string V3437 V3438 (freeze (shen.th* Y string V3437 V3438 V3439)))) (if (shen.pvar? V3314) (do (shen.bindv V3314 string V3438) (let Result (do (shen.incinfs) (shen.th* X string V3437 V3438 (freeze (shen.th* Y string V3437 V3438 V3439)))) (do (shen.unbindv V3314 V3438) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3315 (shen.lazyderef V3435 V3438) (if (cons? V3315) (let V3316 (shen.lazyderef (hd V3315) V3438) (if (= lambda V3316) (let V3317 (shen.lazyderef (tl V3315) V3438) (if (cons? V3317) (let X (hd V3317) (let V3318 (shen.lazyderef (tl V3317) V3438) (if (cons? V3318) (let Y (hd V3318) (let V3319 (shen.lazyderef (tl V3318) V3438) (if (= () V3319) (let V3320 (shen.lazyderef V3436 V3438) (if (cons? V3320) (let A (hd V3320) (let V3321 (shen.lazyderef (tl V3320) V3438) (if (cons? V3321) (let V3322 (shen.lazyderef (hd V3321) V3438) (if (= --> V3322) (let V3323 (shen.lazyderef (tl V3321) V3438) (if (cons? V3323) (let B (hd V3323) (let V3324 (shen.lazyderef (tl V3323) V3438) (if (= () V3324) (let Z (shen.newpv V3438) (let X&& (shen.newpv V3438) (do (shen.incinfs) (cut Throwcontrol V3438 (freeze (bind X&& (shen.placeholder) V3438 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3438) (shen.lazyderef X V3438) (shen.lazyderef Y V3438)) V3438 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3437) V3438 V3439)))))))))) (if (shen.pvar? V3324) (do (shen.bindv V3324 () V3438) (let Result (let Z (shen.newpv V3438) (let X&& (shen.newpv V3438) (do (shen.incinfs) (cut Throwcontrol V3438 (freeze (bind X&& (shen.placeholder) V3438 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3438) (shen.lazyderef X V3438) (shen.lazyderef Y V3438)) V3438 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3437) V3438 V3439)))))))))) (do (shen.unbindv V3324 V3438) Result))) false)))) (if (shen.pvar? V3323) (let B (shen.newpv V3438) (do (shen.bindv V3323 (cons B ()) V3438) (let Result (let Z (shen.newpv V3438) (let X&& (shen.newpv V3438) (do (shen.incinfs) (cut Throwcontrol V3438 (freeze (bind X&& (shen.placeholder) V3438 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3438) (shen.lazyderef X V3438) (shen.lazyderef Y V3438)) V3438 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3437) V3438 V3439)))))))))) (do (shen.unbindv V3323 V3438) Result)))) false))) (if (shen.pvar? V3322) (do (shen.bindv V3322 --> V3438) (let Result (let V3325 (shen.lazyderef (tl V3321) V3438) (if (cons? V3325) (let B (hd V3325) (let V3326 (shen.lazyderef (tl V3325) V3438) (if (= () V3326) (let Z (shen.newpv V3438) (let X&& (shen.newpv V3438) (do (shen.incinfs) (cut Throwcontrol V3438 (freeze (bind X&& (shen.placeholder) V3438 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3438) (shen.lazyderef X V3438) (shen.lazyderef Y V3438)) V3438 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3437) V3438 V3439)))))))))) (if (shen.pvar? V3326) (do (shen.bindv V3326 () V3438) (let Result (let Z (shen.newpv V3438) (let X&& (shen.newpv V3438) (do (shen.incinfs) (cut Throwcontrol V3438 (freeze (bind X&& (shen.placeholder) V3438 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3438) (shen.lazyderef X V3438) (shen.lazyderef Y V3438)) V3438 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3437) V3438 V3439)))))))))) (do (shen.unbindv V3326 V3438) Result))) false)))) (if (shen.pvar? V3325) (let B (shen.newpv V3438) (do (shen.bindv V3325 (cons B ()) V3438) (let Result (let Z (shen.newpv V3438) (let X&& (shen.newpv V3438) (do (shen.incinfs) (cut Throwcontrol V3438 (freeze (bind X&& (shen.placeholder) V3438 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3438) (shen.lazyderef X V3438) (shen.lazyderef Y V3438)) V3438 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3437) V3438 V3439)))))))))) (do (shen.unbindv V3325 V3438) Result)))) false))) (do (shen.unbindv V3322 V3438) Result))) false))) (if (shen.pvar? V3321) (let B (shen.newpv V3438) (do (shen.bindv V3321 (cons --> (cons B ())) V3438) (let Result (let Z (shen.newpv V3438) (let X&& (shen.newpv V3438) (do (shen.incinfs) (cut Throwcontrol V3438 (freeze (bind X&& (shen.placeholder) V3438 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3438) (shen.lazyderef X V3438) (shen.lazyderef Y V3438)) V3438 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3437) V3438 V3439)))))))))) (do (shen.unbindv V3321 V3438) Result)))) false)))) (if (shen.pvar? V3320) (let A (shen.newpv V3438) (let B (shen.newpv V3438) (do (shen.bindv V3320 (cons A (cons --> (cons B ()))) V3438) (let Result (let Z (shen.newpv V3438) (let X&& (shen.newpv V3438) (do (shen.incinfs) (cut Throwcontrol V3438 (freeze (bind X&& (shen.placeholder) V3438 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3438) (shen.lazyderef X V3438) (shen.lazyderef Y V3438)) V3438 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3437) V3438 V3439)))))))))) (do (shen.unbindv V3320 V3438) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3327 (shen.lazyderef V3435 V3438) (if (cons? V3327) (let V3328 (shen.lazyderef (hd V3327) V3438) (if (= let V3328) (let V3329 (shen.lazyderef (tl V3327) V3438) (if (cons? V3329) (let X (hd V3329) (let V3330 (shen.lazyderef (tl V3329) V3438) (if (cons? V3330) (let Y (hd V3330) (let V3331 (shen.lazyderef (tl V3330) V3438) (if (cons? V3331) (let Z (hd V3331) (let V3332 (shen.lazyderef (tl V3331) V3438) (if (= () V3332) (let W (shen.newpv V3438) (let X&& (shen.newpv V3438) (let B (shen.newpv V3438) (do (shen.incinfs) (shen.th* Y B V3437 V3438 (freeze (bind X&& (shen.placeholder) V3438 (freeze (bind W (shen.ebr (shen.lazyderef X&& V3438) (shen.lazyderef X V3438) (shen.lazyderef Z V3438)) V3438 (freeze (shen.th* W V3436 (cons (cons X&& (cons : (cons B ()))) V3437) V3438 V3439))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3333 (shen.lazyderef V3435 V3438) (if (cons? V3333) (let V3334 (shen.lazyderef (hd V3333) V3438) (if (= open V3334) (let V3335 (shen.lazyderef (tl V3333) V3438) (if (cons? V3335) (let FileName (hd V3335) (let V3336 (shen.lazyderef (tl V3335) V3438) (if (cons? V3336) (let Direction3266 (hd V3336) (let V3337 (shen.lazyderef (tl V3336) V3438) (if (= () V3337) (let V3338 (shen.lazyderef V3436 V3438) (if (cons? V3338) (let V3339 (shen.lazyderef (hd V3338) V3438) (if (= stream V3339) (let V3340 (shen.lazyderef (tl V3338) V3438) (if (cons? V3340) (let Direction (hd V3340) (let V3341 (shen.lazyderef (tl V3340) V3438) (if (= () V3341) (do (shen.incinfs) (unify! Direction Direction3266 V3438 (freeze (cut Throwcontrol V3438 (freeze (fwhen (element? (shen.lazyderef Direction V3438) (cons in (cons out ()))) V3438 (freeze (shen.th* FileName string V3437 V3438 V3439)))))))) (if (shen.pvar? V3341) (do (shen.bindv V3341 () V3438) (let Result (do (shen.incinfs) (unify! Direction Direction3266 V3438 (freeze (cut Throwcontrol V3438 (freeze (fwhen (element? (shen.lazyderef Direction V3438) (cons in (cons out ()))) V3438 (freeze (shen.th* FileName string V3437 V3438 V3439)))))))) (do (shen.unbindv V3341 V3438) Result))) false)))) (if (shen.pvar? V3340) (let Direction (shen.newpv V3438) (do (shen.bindv V3340 (cons Direction ()) V3438) (let Result (do (shen.incinfs) (unify! Direction Direction3266 V3438 (freeze (cut Throwcontrol V3438 (freeze (fwhen (element? (shen.lazyderef Direction V3438) (cons in (cons out ()))) V3438 (freeze (shen.th* FileName string V3437 V3438 V3439)))))))) (do (shen.unbindv V3340 V3438) Result)))) false))) (if (shen.pvar? V3339) (do (shen.bindv V3339 stream V3438) (let Result (let V3342 (shen.lazyderef (tl V3338) V3438) (if (cons? V3342) (let Direction (hd V3342) (let V3343 (shen.lazyderef (tl V3342) V3438) (if (= () V3343) (do (shen.incinfs) (unify! Direction Direction3266 V3438 (freeze (cut Throwcontrol V3438 (freeze (fwhen (element? (shen.lazyderef Direction V3438) (cons in (cons out ()))) V3438 (freeze (shen.th* FileName string V3437 V3438 V3439)))))))) (if (shen.pvar? V3343) (do (shen.bindv V3343 () V3438) (let Result (do (shen.incinfs) (unify! Direction Direction3266 V3438 (freeze (cut Throwcontrol V3438 (freeze (fwhen (element? (shen.lazyderef Direction V3438) (cons in (cons out ()))) V3438 (freeze (shen.th* FileName string V3437 V3438 V3439)))))))) (do (shen.unbindv V3343 V3438) Result))) false)))) (if (shen.pvar? V3342) (let Direction (shen.newpv V3438) (do (shen.bindv V3342 (cons Direction ()) V3438) (let Result (do (shen.incinfs) (unify! Direction Direction3266 V3438 (freeze (cut Throwcontrol V3438 (freeze (fwhen (element? (shen.lazyderef Direction V3438) (cons in (cons out ()))) V3438 (freeze (shen.th* FileName string V3437 V3438 V3439)))))))) (do (shen.unbindv V3342 V3438) Result)))) false))) (do (shen.unbindv V3339 V3438) Result))) false))) (if (shen.pvar? V3338) (let Direction (shen.newpv V3438) (do (shen.bindv V3338 (cons stream (cons Direction ())) V3438) (let Result (do (shen.incinfs) (unify! Direction Direction3266 V3438 (freeze (cut Throwcontrol V3438 (freeze (fwhen (element? (shen.lazyderef Direction V3438) (cons in (cons out ()))) V3438 (freeze (shen.th* FileName string V3437 V3438 V3439)))))))) (do (shen.unbindv V3338 V3438) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3344 (shen.lazyderef V3435 V3438) (if (cons? V3344) (let V3345 (shen.lazyderef (hd V3344) V3438) (if (= type V3345) (let V3346 (shen.lazyderef (tl V3344) V3438) (if (cons? V3346) (let X (hd V3346) (let V3347 (shen.lazyderef (tl V3346) V3438) (if (cons? V3347) (let A (hd V3347) (let V3348 (shen.lazyderef (tl V3347) V3438) (if (= () V3348) (do (shen.incinfs) (cut Throwcontrol V3438 (freeze (unify A V3436 V3438 (freeze (shen.th* X A V3437 V3438 V3439)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3349 (shen.lazyderef V3435 V3438) (if (cons? V3349) (let V3350 (shen.lazyderef (hd V3349) V3438) (if (= input+ V3350) (let V3351 (shen.lazyderef (tl V3349) V3438) (if (cons? V3351) (let A (hd V3351) (let V3352 (shen.lazyderef (tl V3351) V3438) (if (cons? V3352) (let Stream (hd V3352) (let V3353 (shen.lazyderef (tl V3352) V3438) (if (= () V3353) (let C (shen.newpv V3438) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V3438)) V3438 (freeze (unify V3436 C V3438 (freeze (shen.th* Stream (cons stream (cons in ())) V3437 V3438 V3439))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3354 (shen.lazyderef V3435 V3438) (if (cons? V3354) (let V3355 (shen.lazyderef (hd V3354) V3438) (if (= set V3355) (let V3356 (shen.lazyderef (tl V3354) V3438) (if (cons? V3356) (let Var (hd V3356) (let V3357 (shen.lazyderef (tl V3356) V3438) (if (cons? V3357) (let Val (hd V3357) (let V3358 (shen.lazyderef (tl V3357) V3438) (if (= () V3358) (do (shen.incinfs) (cut Throwcontrol V3438 (freeze (shen.th* Var symbol V3437 V3438 (freeze (cut Throwcontrol V3438 (freeze (shen.th* (cons value (cons Var ())) V3436 V3437 V3438 (freeze (shen.th* Val V3436 V3437 V3438 V3439)))))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V3438) (do (shen.incinfs) (shen.t*-hyps V3437 NewHyp V3438 (freeze (shen.th* V3435 V3436 NewHyp V3438 V3439))))) (if (= Case false) (let Case (let V3359 (shen.lazyderef V3435 V3438) (if (cons? V3359) (let V3360 (shen.lazyderef (hd V3359) V3438) (if (= define V3360) (let V3361 (shen.lazyderef (tl V3359) V3438) (if (cons? V3361) (let F (hd V3361) (let X (tl V3361) (do (shen.incinfs) (cut Throwcontrol V3438 (freeze (shen.t*-def (cons define (cons F X)) V3436 V3437 V3438 V3439)))))) false)) false)) false)) (if (= Case false) (let Case (let V3362 (shen.lazyderef V3435 V3438) (if (cons? V3362) (let V3363 (shen.lazyderef (hd V3362) V3438) (if (= defmacro V3363) (let V3364 (shen.lazyderef V3436 V3438) (if (= unit V3364) (do (shen.incinfs) (cut Throwcontrol V3438 V3439)) (if (shen.pvar? V3364) (do (shen.bindv V3364 unit V3438) (let Result (do (shen.incinfs) (cut Throwcontrol V3438 V3439)) (do (shen.unbindv V3364 V3438) Result))) false))) false)) false)) (if (= Case false) (let Case (let V3365 (shen.lazyderef V3435 V3438) (if (cons? V3365) (let V3366 (shen.lazyderef (hd V3365) V3438) (if (= shen.process-datatype V3366) (let V3367 (shen.lazyderef V3436 V3438) (if (= symbol V3367) (do (shen.incinfs) (thaw V3439)) (if (shen.pvar? V3367) (do (shen.bindv V3367 symbol V3438) (let Result (do (shen.incinfs) (thaw V3439)) (do (shen.unbindv V3367 V3438) Result))) false))) false)) false)) (if (= Case false) (let Case (let V3368 (shen.lazyderef V3435 V3438) (if (cons? V3368) (let V3369 (shen.lazyderef (hd V3368) V3438) (if (= shen.synonyms-help V3369) (let V3370 (shen.lazyderef V3436 V3438) (if (= symbol V3370) (do (shen.incinfs) (thaw V3439)) (if (shen.pvar? V3370) (do (shen.bindv V3370 symbol V3438) (let Result (do (shen.incinfs) (thaw V3439)) (do (shen.unbindv V3370 V3438) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V3438) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V3438 (freeze (shen.udefs* (cons V3435 (cons : (cons V3436 ()))) V3437 Datatypes V3438 V3439))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V3444 V3445 V3446 V3447) (let Case (let V3181 (shen.lazyderef V3444 V3446) (if (cons? V3181) (let V3182 (shen.lazyderef (hd V3181) V3446) (if (cons? V3182) (let V3183 (shen.lazyderef (hd V3182) V3446) (if (cons? V3183) (let V3184 (shen.lazyderef (hd V3183) V3446) (if (= cons V3184) (let V3185 (shen.lazyderef (tl V3183) V3446) (if (cons? V3185) (let X (hd V3185) (let V3186 (shen.lazyderef (tl V3185) V3446) (if (cons? V3186) (let Y (hd V3186) (let V3187 (shen.lazyderef (tl V3186) V3446) (if (= () V3187) (let V3188 (shen.lazyderef (tl V3182) V3446) (if (cons? V3188) (let V3189 (shen.lazyderef (hd V3188) V3446) (if (= : V3189) (let V3190 (shen.lazyderef (tl V3188) V3446) (if (cons? V3190) (let V3191 (shen.lazyderef (hd V3190) V3446) (if (cons? V3191) (let V3192 (shen.lazyderef (hd V3191) V3446) (if (= list V3192) (let V3193 (shen.lazyderef (tl V3191) V3446) (if (cons? V3193) (let A (hd V3193) (let V3194 (shen.lazyderef (tl V3193) V3446) (if (= () V3194) (let V3195 (shen.lazyderef (tl V3190) V3446) (if (= () V3195) (let Hyp (tl V3181) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (cons list (cons (shen.lazyderef A V3446) ())) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (if (shen.pvar? V3195) (do (shen.bindv V3195 () V3446) (let Result (let Hyp (tl V3181) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (cons list (cons (shen.lazyderef A V3446) ())) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (do (shen.unbindv V3195 V3446) Result))) false))) (if (shen.pvar? V3194) (do (shen.bindv V3194 () V3446) (let Result (let V3196 (shen.lazyderef (tl V3190) V3446) (if (= () V3196) (let Hyp (tl V3181) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (cons list (cons (shen.lazyderef A V3446) ())) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (if (shen.pvar? V3196) (do (shen.bindv V3196 () V3446) (let Result (let Hyp (tl V3181) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (cons list (cons (shen.lazyderef A V3446) ())) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (do (shen.unbindv V3196 V3446) Result))) false))) (do (shen.unbindv V3194 V3446) Result))) false)))) (if (shen.pvar? V3193) (let A (shen.newpv V3446) (do (shen.bindv V3193 (cons A ()) V3446) (let Result (let V3197 (shen.lazyderef (tl V3190) V3446) (if (= () V3197) (let Hyp (tl V3181) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (cons list (cons (shen.lazyderef A V3446) ())) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (if (shen.pvar? V3197) (do (shen.bindv V3197 () V3446) (let Result (let Hyp (tl V3181) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (cons list (cons (shen.lazyderef A V3446) ())) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (do (shen.unbindv V3197 V3446) Result))) false))) (do (shen.unbindv V3193 V3446) Result)))) false))) (if (shen.pvar? V3192) (do (shen.bindv V3192 list V3446) (let Result (let V3198 (shen.lazyderef (tl V3191) V3446) (if (cons? V3198) (let A (hd V3198) (let V3199 (shen.lazyderef (tl V3198) V3446) (if (= () V3199) (let V3200 (shen.lazyderef (tl V3190) V3446) (if (= () V3200) (let Hyp (tl V3181) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (cons list (cons (shen.lazyderef A V3446) ())) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (if (shen.pvar? V3200) (do (shen.bindv V3200 () V3446) (let Result (let Hyp (tl V3181) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (cons list (cons (shen.lazyderef A V3446) ())) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (do (shen.unbindv V3200 V3446) Result))) false))) (if (shen.pvar? V3199) (do (shen.bindv V3199 () V3446) (let Result (let V3201 (shen.lazyderef (tl V3190) V3446) (if (= () V3201) (let Hyp (tl V3181) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (cons list (cons (shen.lazyderef A V3446) ())) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (if (shen.pvar? V3201) (do (shen.bindv V3201 () V3446) (let Result (let Hyp (tl V3181) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (cons list (cons (shen.lazyderef A V3446) ())) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (do (shen.unbindv V3201 V3446) Result))) false))) (do (shen.unbindv V3199 V3446) Result))) false)))) (if (shen.pvar? V3198) (let A (shen.newpv V3446) (do (shen.bindv V3198 (cons A ()) V3446) (let Result (let V3202 (shen.lazyderef (tl V3190) V3446) (if (= () V3202) (let Hyp (tl V3181) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (cons list (cons (shen.lazyderef A V3446) ())) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (if (shen.pvar? V3202) (do (shen.bindv V3202 () V3446) (let Result (let Hyp (tl V3181) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (cons list (cons (shen.lazyderef A V3446) ())) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (do (shen.unbindv V3202 V3446) Result))) false))) (do (shen.unbindv V3198 V3446) Result)))) false))) (do (shen.unbindv V3192 V3446) Result))) false))) (if (shen.pvar? V3191) (let A (shen.newpv V3446) (do (shen.bindv V3191 (cons list (cons A ())) V3446) (let Result (let V3203 (shen.lazyderef (tl V3190) V3446) (if (= () V3203) (let Hyp (tl V3181) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (cons list (cons (shen.lazyderef A V3446) ())) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (if (shen.pvar? V3203) (do (shen.bindv V3203 () V3446) (let Result (let Hyp (tl V3181) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (cons list (cons (shen.lazyderef A V3446) ())) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (do (shen.unbindv V3203 V3446) Result))) false))) (do (shen.unbindv V3191 V3446) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3204 (shen.lazyderef V3444 V3446) (if (cons? V3204) (let V3205 (shen.lazyderef (hd V3204) V3446) (if (cons? V3205) (let V3206 (shen.lazyderef (hd V3205) V3446) (if (cons? V3206) (let V3207 (shen.lazyderef (hd V3206) V3446) (if (= @p V3207) (let V3208 (shen.lazyderef (tl V3206) V3446) (if (cons? V3208) (let X (hd V3208) (let V3209 (shen.lazyderef (tl V3208) V3446) (if (cons? V3209) (let Y (hd V3209) (let V3210 (shen.lazyderef (tl V3209) V3446) (if (= () V3210) (let V3211 (shen.lazyderef (tl V3205) V3446) (if (cons? V3211) (let V3212 (shen.lazyderef (hd V3211) V3446) (if (= : V3212) (let V3213 (shen.lazyderef (tl V3211) V3446) (if (cons? V3213) (let V3214 (shen.lazyderef (hd V3213) V3446) (if (cons? V3214) (let A (hd V3214) (let V3215 (shen.lazyderef (tl V3214) V3446) (if (cons? V3215) (let V3216 (shen.lazyderef (hd V3215) V3446) (if (= * V3216) (let V3217 (shen.lazyderef (tl V3215) V3446) (if (cons? V3217) (let B (hd V3217) (let V3218 (shen.lazyderef (tl V3217) V3446) (if (= () V3218) (let V3219 (shen.lazyderef (tl V3213) V3446) (if (= () V3219) (let Hyp (tl V3204) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (shen.lazyderef B V3446) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (if (shen.pvar? V3219) (do (shen.bindv V3219 () V3446) (let Result (let Hyp (tl V3204) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (shen.lazyderef B V3446) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (do (shen.unbindv V3219 V3446) Result))) false))) (if (shen.pvar? V3218) (do (shen.bindv V3218 () V3446) (let Result (let V3220 (shen.lazyderef (tl V3213) V3446) (if (= () V3220) (let Hyp (tl V3204) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (shen.lazyderef B V3446) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (if (shen.pvar? V3220) (do (shen.bindv V3220 () V3446) (let Result (let Hyp (tl V3204) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (shen.lazyderef B V3446) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (do (shen.unbindv V3220 V3446) Result))) false))) (do (shen.unbindv V3218 V3446) Result))) false)))) (if (shen.pvar? V3217) (let B (shen.newpv V3446) (do (shen.bindv V3217 (cons B ()) V3446) (let Result (let V3221 (shen.lazyderef (tl V3213) V3446) (if (= () V3221) (let Hyp (tl V3204) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (shen.lazyderef B V3446) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (if (shen.pvar? V3221) (do (shen.bindv V3221 () V3446) (let Result (let Hyp (tl V3204) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (shen.lazyderef B V3446) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (do (shen.unbindv V3221 V3446) Result))) false))) (do (shen.unbindv V3217 V3446) Result)))) false))) (if (shen.pvar? V3216) (do (shen.bindv V3216 * V3446) (let Result (let V3222 (shen.lazyderef (tl V3215) V3446) (if (cons? V3222) (let B (hd V3222) (let V3223 (shen.lazyderef (tl V3222) V3446) (if (= () V3223) (let V3224 (shen.lazyderef (tl V3213) V3446) (if (= () V3224) (let Hyp (tl V3204) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (shen.lazyderef B V3446) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (if (shen.pvar? V3224) (do (shen.bindv V3224 () V3446) (let Result (let Hyp (tl V3204) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (shen.lazyderef B V3446) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (do (shen.unbindv V3224 V3446) Result))) false))) (if (shen.pvar? V3223) (do (shen.bindv V3223 () V3446) (let Result (let V3225 (shen.lazyderef (tl V3213) V3446) (if (= () V3225) (let Hyp (tl V3204) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (shen.lazyderef B V3446) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (if (shen.pvar? V3225) (do (shen.bindv V3225 () V3446) (let Result (let Hyp (tl V3204) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (shen.lazyderef B V3446) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (do (shen.unbindv V3225 V3446) Result))) false))) (do (shen.unbindv V3223 V3446) Result))) false)))) (if (shen.pvar? V3222) (let B (shen.newpv V3446) (do (shen.bindv V3222 (cons B ()) V3446) (let Result (let V3226 (shen.lazyderef (tl V3213) V3446) (if (= () V3226) (let Hyp (tl V3204) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (shen.lazyderef B V3446) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (if (shen.pvar? V3226) (do (shen.bindv V3226 () V3446) (let Result (let Hyp (tl V3204) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (shen.lazyderef B V3446) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (do (shen.unbindv V3226 V3446) Result))) false))) (do (shen.unbindv V3222 V3446) Result)))) false))) (do (shen.unbindv V3216 V3446) Result))) false))) (if (shen.pvar? V3215) (let B (shen.newpv V3446) (do (shen.bindv V3215 (cons * (cons B ())) V3446) (let Result (let V3227 (shen.lazyderef (tl V3213) V3446) (if (= () V3227) (let Hyp (tl V3204) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (shen.lazyderef B V3446) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (if (shen.pvar? V3227) (do (shen.bindv V3227 () V3446) (let Result (let Hyp (tl V3204) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (shen.lazyderef B V3446) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (do (shen.unbindv V3227 V3446) Result))) false))) (do (shen.unbindv V3215 V3446) Result)))) false)))) (if (shen.pvar? V3214) (let A (shen.newpv V3446) (let B (shen.newpv V3446) (do (shen.bindv V3214 (cons A (cons * (cons B ()))) V3446) (let Result (let V3228 (shen.lazyderef (tl V3213) V3446) (if (= () V3228) (let Hyp (tl V3204) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (shen.lazyderef B V3446) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (if (shen.pvar? V3228) (do (shen.bindv V3228 () V3446) (let Result (let Hyp (tl V3204) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (shen.lazyderef B V3446) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (do (shen.unbindv V3228 V3446) Result))) false))) (do (shen.unbindv V3214 V3446) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3229 (shen.lazyderef V3444 V3446) (if (cons? V3229) (let V3230 (shen.lazyderef (hd V3229) V3446) (if (cons? V3230) (let V3231 (shen.lazyderef (hd V3230) V3446) (if (cons? V3231) (let V3232 (shen.lazyderef (hd V3231) V3446) (if (= @v V3232) (let V3233 (shen.lazyderef (tl V3231) V3446) (if (cons? V3233) (let X (hd V3233) (let V3234 (shen.lazyderef (tl V3233) V3446) (if (cons? V3234) (let Y (hd V3234) (let V3235 (shen.lazyderef (tl V3234) V3446) (if (= () V3235) (let V3236 (shen.lazyderef (tl V3230) V3446) (if (cons? V3236) (let V3237 (shen.lazyderef (hd V3236) V3446) (if (= : V3237) (let V3238 (shen.lazyderef (tl V3236) V3446) (if (cons? V3238) (let V3239 (shen.lazyderef (hd V3238) V3446) (if (cons? V3239) (let V3240 (shen.lazyderef (hd V3239) V3446) (if (= vector V3240) (let V3241 (shen.lazyderef (tl V3239) V3446) (if (cons? V3241) (let A (hd V3241) (let V3242 (shen.lazyderef (tl V3241) V3446) (if (= () V3242) (let V3243 (shen.lazyderef (tl V3238) V3446) (if (= () V3243) (let Hyp (tl V3229) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (cons vector (cons (shen.lazyderef A V3446) ())) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (if (shen.pvar? V3243) (do (shen.bindv V3243 () V3446) (let Result (let Hyp (tl V3229) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (cons vector (cons (shen.lazyderef A V3446) ())) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (do (shen.unbindv V3243 V3446) Result))) false))) (if (shen.pvar? V3242) (do (shen.bindv V3242 () V3446) (let Result (let V3244 (shen.lazyderef (tl V3238) V3446) (if (= () V3244) (let Hyp (tl V3229) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (cons vector (cons (shen.lazyderef A V3446) ())) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (if (shen.pvar? V3244) (do (shen.bindv V3244 () V3446) (let Result (let Hyp (tl V3229) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (cons vector (cons (shen.lazyderef A V3446) ())) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (do (shen.unbindv V3244 V3446) Result))) false))) (do (shen.unbindv V3242 V3446) Result))) false)))) (if (shen.pvar? V3241) (let A (shen.newpv V3446) (do (shen.bindv V3241 (cons A ()) V3446) (let Result (let V3245 (shen.lazyderef (tl V3238) V3446) (if (= () V3245) (let Hyp (tl V3229) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (cons vector (cons (shen.lazyderef A V3446) ())) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (if (shen.pvar? V3245) (do (shen.bindv V3245 () V3446) (let Result (let Hyp (tl V3229) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (cons vector (cons (shen.lazyderef A V3446) ())) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (do (shen.unbindv V3245 V3446) Result))) false))) (do (shen.unbindv V3241 V3446) Result)))) false))) (if (shen.pvar? V3240) (do (shen.bindv V3240 vector V3446) (let Result (let V3246 (shen.lazyderef (tl V3239) V3446) (if (cons? V3246) (let A (hd V3246) (let V3247 (shen.lazyderef (tl V3246) V3446) (if (= () V3247) (let V3248 (shen.lazyderef (tl V3238) V3446) (if (= () V3248) (let Hyp (tl V3229) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (cons vector (cons (shen.lazyderef A V3446) ())) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (if (shen.pvar? V3248) (do (shen.bindv V3248 () V3446) (let Result (let Hyp (tl V3229) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (cons vector (cons (shen.lazyderef A V3446) ())) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (do (shen.unbindv V3248 V3446) Result))) false))) (if (shen.pvar? V3247) (do (shen.bindv V3247 () V3446) (let Result (let V3249 (shen.lazyderef (tl V3238) V3446) (if (= () V3249) (let Hyp (tl V3229) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (cons vector (cons (shen.lazyderef A V3446) ())) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (if (shen.pvar? V3249) (do (shen.bindv V3249 () V3446) (let Result (let Hyp (tl V3229) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (cons vector (cons (shen.lazyderef A V3446) ())) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (do (shen.unbindv V3249 V3446) Result))) false))) (do (shen.unbindv V3247 V3446) Result))) false)))) (if (shen.pvar? V3246) (let A (shen.newpv V3446) (do (shen.bindv V3246 (cons A ()) V3446) (let Result (let V3250 (shen.lazyderef (tl V3238) V3446) (if (= () V3250) (let Hyp (tl V3229) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (cons vector (cons (shen.lazyderef A V3446) ())) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (if (shen.pvar? V3250) (do (shen.bindv V3250 () V3446) (let Result (let Hyp (tl V3229) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (cons vector (cons (shen.lazyderef A V3446) ())) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (do (shen.unbindv V3250 V3446) Result))) false))) (do (shen.unbindv V3246 V3446) Result)))) false))) (do (shen.unbindv V3240 V3446) Result))) false))) (if (shen.pvar? V3239) (let A (shen.newpv V3446) (do (shen.bindv V3239 (cons vector (cons A ())) V3446) (let Result (let V3251 (shen.lazyderef (tl V3238) V3446) (if (= () V3251) (let Hyp (tl V3229) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (cons vector (cons (shen.lazyderef A V3446) ())) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (if (shen.pvar? V3251) (do (shen.bindv V3251 () V3446) (let Result (let Hyp (tl V3229) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons (shen.lazyderef A V3446) ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons (cons vector (cons (shen.lazyderef A V3446) ())) ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (do (shen.unbindv V3251 V3446) Result))) false))) (do (shen.unbindv V3239 V3446) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3252 (shen.lazyderef V3444 V3446) (if (cons? V3252) (let V3253 (shen.lazyderef (hd V3252) V3446) (if (cons? V3253) (let V3254 (shen.lazyderef (hd V3253) V3446) (if (cons? V3254) (let V3255 (shen.lazyderef (hd V3254) V3446) (if (= @s V3255) (let V3256 (shen.lazyderef (tl V3254) V3446) (if (cons? V3256) (let X (hd V3256) (let V3257 (shen.lazyderef (tl V3256) V3446) (if (cons? V3257) (let Y (hd V3257) (let V3258 (shen.lazyderef (tl V3257) V3446) (if (= () V3258) (let V3259 (shen.lazyderef (tl V3253) V3446) (if (cons? V3259) (let V3260 (shen.lazyderef (hd V3259) V3446) (if (= : V3260) (let V3261 (shen.lazyderef (tl V3259) V3446) (if (cons? V3261) (let V3262 (shen.lazyderef (hd V3261) V3446) (if (= string V3262) (let V3263 (shen.lazyderef (tl V3261) V3446) (if (= () V3263) (let Hyp (tl V3252) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons string ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (if (shen.pvar? V3263) (do (shen.bindv V3263 () V3446) (let Result (let Hyp (tl V3252) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons string ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (do (shen.unbindv V3263 V3446) Result))) false))) (if (shen.pvar? V3262) (do (shen.bindv V3262 string V3446) (let Result (let V3264 (shen.lazyderef (tl V3261) V3446) (if (= () V3264) (let Hyp (tl V3252) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons string ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (if (shen.pvar? V3264) (do (shen.bindv V3264 () V3446) (let Result (let Hyp (tl V3252) (do (shen.incinfs) (bind V3445 (cons (cons (shen.lazyderef X V3446) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3446) (cons : (cons string ()))) (shen.lazyderef Hyp V3446))) V3446 V3447))) (do (shen.unbindv V3264 V3446) Result))) false))) (do (shen.unbindv V3262 V3446) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V3265 (shen.lazyderef V3444 V3446) (if (cons? V3265) (let X (hd V3265) (let Hyp (tl V3265) (let NewHyps (shen.newpv V3446) (do (shen.incinfs) (bind V3445 (cons (shen.lazyderef X V3446) (shen.lazyderef NewHyps V3446)) V3446 (freeze (shen.t*-hyps Hyp NewHyps V3446 V3447))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V3464 V3465 V3466 V3467) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V3464 V3466)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V3465 V3466) 1) (do (shen.prhush "
> " (stoutput)) (do (shen.pause-for-user) (thaw V3467))))))))) (true (thaw V3467))))

(defun shen.line () (let Infs (inferences) (shen.prhush (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V3469) (cond ((and (cons? V3469) (and (cons? (tl V3469)) (and (= : (hd (tl V3469))) (and (cons? (tl (tl V3469))) (= () (tl (tl (tl V3469)))))))) (shen.prhush (shen.app (hd V3469) (cn " : " (shen.app (hd (tl (tl V3469))) "" shen.r)) shen.r) (stoutput))) (true (shen.prhush (shen.app V3469 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V3474 V3475) (cond ((= () V3474) shen.skip) ((cons? V3474) (do (shen.prhush (shen.app V3475 ". " shen.a) (stoutput)) (do (shen.show-p (hd V3474)) (do (nl 1) (shen.show-assumptions (tl V3474) (+ V3475 1)))))) (true (shen.f_error shen.show-assumptions))))

(defun shen.pause-for-user () (let Byte (read-byte (stinput)) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.typedf? (V3477) (cons? (assoc V3477 (value shen.*signedfuncs*))))

(defun shen.sigf (V3479) (concat shen.type-signature-of- V3479))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V3484 V3485 V3486 V3487) (let Case (let V3168 (shen.lazyderef V3485 V3486) (if (= number V3168) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V3484 V3486)) V3486 V3487)) (if (shen.pvar? V3168) (do (shen.bindv V3168 number V3486) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V3484 V3486)) V3486 V3487)) (do (shen.unbindv V3168 V3486) Result))) false))) (if (= Case false) (let Case (let V3169 (shen.lazyderef V3485 V3486) (if (= boolean V3169) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V3484 V3486)) V3486 V3487)) (if (shen.pvar? V3169) (do (shen.bindv V3169 boolean V3486) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V3484 V3486)) V3486 V3487)) (do (shen.unbindv V3169 V3486) Result))) false))) (if (= Case false) (let Case (let V3170 (shen.lazyderef V3485 V3486) (if (= string V3170) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V3484 V3486)) V3486 V3487)) (if (shen.pvar? V3170) (do (shen.bindv V3170 string V3486) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V3484 V3486)) V3486 V3487)) (do (shen.unbindv V3170 V3486) Result))) false))) (if (= Case false) (let Case (let V3171 (shen.lazyderef V3485 V3486) (if (= symbol V3171) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V3484 V3486)) V3486 (freeze (fwhen (not (shen.ue? (shen.lazyderef V3484 V3486))) V3486 V3487)))) (if (shen.pvar? V3171) (do (shen.bindv V3171 symbol V3486) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V3484 V3486)) V3486 (freeze (fwhen (not (shen.ue? (shen.lazyderef V3484 V3486))) V3486 V3487)))) (do (shen.unbindv V3171 V3486) Result))) false))) (if (= Case false) (let V3172 (shen.lazyderef V3484 V3486) (if (= () V3172) (let V3173 (shen.lazyderef V3485 V3486) (if (cons? V3173) (let V3174 (shen.lazyderef (hd V3173) V3486) (if (= list V3174) (let V3175 (shen.lazyderef (tl V3173) V3486) (if (cons? V3175) (let A (hd V3175) (let V3176 (shen.lazyderef (tl V3175) V3486) (if (= () V3176) (do (shen.incinfs) (thaw V3487)) (if (shen.pvar? V3176) (do (shen.bindv V3176 () V3486) (let Result (do (shen.incinfs) (thaw V3487)) (do (shen.unbindv V3176 V3486) Result))) false)))) (if (shen.pvar? V3175) (let A (shen.newpv V3486) (do (shen.bindv V3175 (cons A ()) V3486) (let Result (do (shen.incinfs) (thaw V3487)) (do (shen.unbindv V3175 V3486) Result)))) false))) (if (shen.pvar? V3174) (do (shen.bindv V3174 list V3486) (let Result (let V3177 (shen.lazyderef (tl V3173) V3486) (if (cons? V3177) (let A (hd V3177) (let V3178 (shen.lazyderef (tl V3177) V3486) (if (= () V3178) (do (shen.incinfs) (thaw V3487)) (if (shen.pvar? V3178) (do (shen.bindv V3178 () V3486) (let Result (do (shen.incinfs) (thaw V3487)) (do (shen.unbindv V3178 V3486) Result))) false)))) (if (shen.pvar? V3177) (let A (shen.newpv V3486) (do (shen.bindv V3177 (cons A ()) V3486) (let Result (do (shen.incinfs) (thaw V3487)) (do (shen.unbindv V3177 V3486) Result)))) false))) (do (shen.unbindv V3174 V3486) Result))) false))) (if (shen.pvar? V3173) (let A (shen.newpv V3486) (do (shen.bindv V3173 (cons list (cons A ())) V3486) (let Result (do (shen.incinfs) (thaw V3487)) (do (shen.unbindv V3173 V3486) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.by_hypothesis (V3493 V3494 V3495 V3496 V3497) (let Case (let V3159 (shen.lazyderef V3495 V3496) (if (cons? V3159) (let V3160 (shen.lazyderef (hd V3159) V3496) (if (cons? V3160) (let Y (hd V3160) (let V3161 (shen.lazyderef (tl V3160) V3496) (if (cons? V3161) (let V3162 (shen.lazyderef (hd V3161) V3496) (if (= : V3162) (let V3163 (shen.lazyderef (tl V3161) V3496) (if (cons? V3163) (let B (hd V3163) (let V3164 (shen.lazyderef (tl V3163) V3496) (if (= () V3164) (do (shen.incinfs) (identical V3493 Y V3496 (freeze (unify! V3494 B V3496 V3497)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V3165 (shen.lazyderef V3495 V3496) (if (cons? V3165) (let Hyp (tl V3165) (do (shen.incinfs) (shen.by_hypothesis V3493 V3494 Hyp V3496 V3497))) false)) Case)))

(defun shen.t*-def (V3503 V3504 V3505 V3506 V3507) (let V3153 (shen.lazyderef V3503 V3506) (if (cons? V3153) (let V3154 (shen.lazyderef (hd V3153) V3506) (if (= define V3154) (let V3155 (shen.lazyderef (tl V3153) V3506) (if (cons? V3155) (let F (hd V3155) (let X (tl V3155) (let Y (shen.newpv V3506) (let E (shen.newpv V3506) (do (shen.incinfs) (shen.t*-defh (compile (lambda Y (shen.<sig+rules> Y)) X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V3504 V3505 V3506 V3507)))))) false)) false)) false)))

(defun shen.t*-defh (V3514 V3515 V3516 V3517 V3518 V3519) (let V3149 (shen.lazyderef V3514 V3518) (if (cons? V3149) (let Sig (hd V3149) (let Rules (tl V3149) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue-sig Sig) V3515 V3516 V3517 Rules V3518 V3519)))) false)))

(defun shen.t*-defhh (V3528 V3529 V3530 V3531 V3532 V3533 V3534 V3535) (do (shen.incinfs) (shen.t*-rules V3533 V3529 1 V3530 (cons (cons V3530 (cons : (cons V3529 ()))) V3532) V3534 (freeze (shen.memo V3530 V3528 V3531 V3534 V3535)))))

(defun shen.memo (V3541 V3542 V3543 V3544 V3545) (let Jnk (shen.newpv V3544) (do (shen.incinfs) (unify! V3543 V3542 V3544 (freeze (bind Jnk (declare (shen.lazyderef V3541 V3544) (shen.lazyderef V3543 V3544)) V3544 V3545))))))

(defun shen.<sig+rules> (V3547) (let Parse_shen.<signature> (shen.<signature> V3547) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))))

(defun shen.<non-ll-rules> (V3549) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V3549) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<rule>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V3549) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.hdtl Parse_shen.<rule>) ())) (fail))) YaccParse)))

(defun shen.ue (V3551) (cond ((and (cons? V3551) (and (cons? (tl V3551)) (and (= () (tl (tl V3551))) (= (hd V3551) protect)))) V3551) ((cons? V3551) (map (lambda Z (shen.ue Z)) V3551)) ((variable? V3551) (concat && V3551)) (true V3551)))

(defun shen.ue-sig (V3553) (cond ((cons? V3553) (map (lambda Z (shen.ue-sig Z)) V3553)) ((variable? V3553) (concat &&& V3553)) (true V3553)))

(defun shen.ues (V3559) (cond ((shen.ue? V3559) (cons V3559 ())) ((cons? V3559) (union (shen.ues (hd V3559)) (shen.ues (tl V3559)))) (true ())))

(defun shen.ue? (V3561) (and (symbol? V3561) (shen.ue-h? (str V3561))))

(defun shen.ue-h? (V3569) (cond ((and (shen.+string? V3569) (and (= "&" (pos V3569 0)) (and (shen.+string? (tlstr V3569)) (= "&" (pos (tlstr V3569) 0))))) true) (true false)))

(defun shen.t*-rules (V3577 V3578 V3579 V3580 V3581 V3582 V3583) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V3133 (shen.lazyderef V3577 V3582) (if (= () V3133) (do (shen.incinfs) (thaw V3583)) false)) (if (= Case false) (let Case (let V3134 (shen.lazyderef V3577 V3582) (if (cons? V3134) (let Rule (hd V3134) (let Rules (tl V3134) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V3578 V3581 V3582 (freeze (cut Throwcontrol V3582 (freeze (shen.t*-rules Rules V3578 (+ V3579 1) V3580 V3581 V3582 V3583)))))))) false)) (if (= Case false) (let Err (shen.newpv V3582) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V3579 V3582) (cn " of " (shen.app (shen.lazyderef V3580 V3582) "" shen.a)) shen.a))) V3582 V3583))) Case)) Case)))))

(defun shen.t*-rule (V3589 V3590 V3591 V3592 V3593) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V3125 (shen.lazyderef V3589 V3592) (if (cons? V3125) (let Patterns (hd V3125) (let V3126 (shen.lazyderef (tl V3125) V3592) (if (cons? V3126) (let Action (hd V3126) (let V3127 (shen.lazyderef (tl V3126) V3592) (if (= () V3127) (let NewHyps (shen.newpv V3592) (do (shen.incinfs) (shen.newhyps (shen.placeholders Patterns) V3591 NewHyps V3592 (freeze (shen.t*-patterns Patterns V3590 NewHyps V3592 (freeze (cut Throwcontrol V3592 (freeze (shen.t*-action (shen.curry (shen.ue Action)) (shen.result-type Patterns V3590) (shen.patthyps Patterns V3590 V3591) V3592 V3593))))))))) false))) false))) false)))))

(defun shen.placeholders (V3599) (cond ((shen.ue? V3599) (cons V3599 ())) ((cons? V3599) (union (shen.placeholders (hd V3599)) (shen.placeholders (tl V3599)))) (true ())))

(defun shen.newhyps (V3605 V3606 V3607 V3608 V3609) (let Case (let V3112 (shen.lazyderef V3605 V3608) (if (= () V3112) (do (shen.incinfs) (unify! V3607 V3606 V3608 V3609)) false)) (if (= Case false) (let V3113 (shen.lazyderef V3605 V3608) (if (cons? V3113) (let V3108 (hd V3113) (let Vs (tl V3113) (let V3114 (shen.lazyderef V3607 V3608) (if (cons? V3114) (let V3115 (shen.lazyderef (hd V3114) V3608) (if (cons? V3115) (let V (hd V3115) (let V3116 (shen.lazyderef (tl V3115) V3608) (if (cons? V3116) (let V3117 (shen.lazyderef (hd V3116) V3608) (if (= : V3117) (let V3118 (shen.lazyderef (tl V3116) V3608) (if (cons? V3118) (let A (hd V3118) (let V3119 (shen.lazyderef (tl V3118) V3608) (if (= () V3119) (let NewHyp (tl V3114) (do (shen.incinfs) (unify! V V3108 V3608 (freeze (shen.newhyps Vs V3606 NewHyp V3608 V3609))))) (if (shen.pvar? V3119) (do (shen.bindv V3119 () V3608) (let Result (let NewHyp (tl V3114) (do (shen.incinfs) (unify! V V3108 V3608 (freeze (shen.newhyps Vs V3606 NewHyp V3608 V3609))))) (do (shen.unbindv V3119 V3608) Result))) false)))) (if (shen.pvar? V3118) (let A (shen.newpv V3608) (do (shen.bindv V3118 (cons A ()) V3608) (let Result (let NewHyp (tl V3114) (do (shen.incinfs) (unify! V V3108 V3608 (freeze (shen.newhyps Vs V3606 NewHyp V3608 V3609))))) (do (shen.unbindv V3118 V3608) Result)))) false))) (if (shen.pvar? V3117) (do (shen.bindv V3117 : V3608) (let Result (let V3120 (shen.lazyderef (tl V3116) V3608) (if (cons? V3120) (let A (hd V3120) (let V3121 (shen.lazyderef (tl V3120) V3608) (if (= () V3121) (let NewHyp (tl V3114) (do (shen.incinfs) (unify! V V3108 V3608 (freeze (shen.newhyps Vs V3606 NewHyp V3608 V3609))))) (if (shen.pvar? V3121) (do (shen.bindv V3121 () V3608) (let Result (let NewHyp (tl V3114) (do (shen.incinfs) (unify! V V3108 V3608 (freeze (shen.newhyps Vs V3606 NewHyp V3608 V3609))))) (do (shen.unbindv V3121 V3608) Result))) false)))) (if (shen.pvar? V3120) (let A (shen.newpv V3608) (do (shen.bindv V3120 (cons A ()) V3608) (let Result (let NewHyp (tl V3114) (do (shen.incinfs) (unify! V V3108 V3608 (freeze (shen.newhyps Vs V3606 NewHyp V3608 V3609))))) (do (shen.unbindv V3120 V3608) Result)))) false))) (do (shen.unbindv V3117 V3608) Result))) false))) (if (shen.pvar? V3116) (let A (shen.newpv V3608) (do (shen.bindv V3116 (cons : (cons A ())) V3608) (let Result (let NewHyp (tl V3114) (do (shen.incinfs) (unify! V V3108 V3608 (freeze (shen.newhyps Vs V3606 NewHyp V3608 V3609))))) (do (shen.unbindv V3116 V3608) Result)))) false)))) (if (shen.pvar? V3115) (let V (shen.newpv V3608) (let A (shen.newpv V3608) (do (shen.bindv V3115 (cons V (cons : (cons A ()))) V3608) (let Result (let NewHyp (tl V3114) (do (shen.incinfs) (unify! V V3108 V3608 (freeze (shen.newhyps Vs V3606 NewHyp V3608 V3609))))) (do (shen.unbindv V3115 V3608) Result))))) false))) (if (shen.pvar? V3114) (let V (shen.newpv V3608) (let A (shen.newpv V3608) (let NewHyp (shen.newpv V3608) (do (shen.bindv V3114 (cons (cons V (cons : (cons A ()))) NewHyp) V3608) (let Result (do (shen.incinfs) (unify! V V3108 V3608 (freeze (shen.newhyps Vs V3606 NewHyp V3608 V3609)))) (do (shen.unbindv V3114 V3608) Result)))))) false))))) false)) Case)))

(defun shen.patthyps (V3615 V3616 V3617) (cond ((= () V3615) V3617) ((and (cons? V3615) (and (cons? V3616) (and (cons? (tl V3616)) (and (= --> (hd (tl V3616))) (and (cons? (tl (tl V3616))) (= () (tl (tl (tl V3616))))))))) (adjoin (cons (hd V3615) (cons : (cons (hd V3616) ()))) (shen.patthyps (tl V3615) (hd (tl (tl V3616))) V3617))) (true (shen.f_error shen.patthyps))))

(defun shen.result-type (V3624 V3625) (cond ((and (= () V3624) (and (cons? V3625) (and (= --> (hd V3625)) (and (cons? (tl V3625)) (= () (tl (tl V3625))))))) (hd (tl V3625))) ((= () V3624) V3625) ((and (cons? V3624) (and (cons? V3625) (and (cons? (tl V3625)) (and (= --> (hd (tl V3625))) (and (cons? (tl (tl V3625))) (= () (tl (tl (tl V3625))))))))) (shen.result-type (tl V3624) (hd (tl (tl V3625))))) (true (shen.f_error shen.result-type))))

(defun shen.t*-patterns (V3631 V3632 V3633 V3634 V3635) (let Case (let V3100 (shen.lazyderef V3631 V3634) (if (= () V3100) (do (shen.incinfs) (thaw V3635)) false)) (if (= Case false) (let V3101 (shen.lazyderef V3631 V3634) (if (cons? V3101) (let Pattern (hd V3101) (let Patterns (tl V3101) (let V3102 (shen.lazyderef V3632 V3634) (if (cons? V3102) (let A (hd V3102) (let V3103 (shen.lazyderef (tl V3102) V3634) (if (cons? V3103) (let V3104 (shen.lazyderef (hd V3103) V3634) (if (= --> V3104) (let V3105 (shen.lazyderef (tl V3103) V3634) (if (cons? V3105) (let B (hd V3105) (let V3106 (shen.lazyderef (tl V3105) V3634) (if (= () V3106) (do (shen.incinfs) (shen.t* (cons Pattern (cons : (cons A ()))) V3633 V3634 (freeze (shen.t*-patterns Patterns B V3633 V3634 V3635)))) false))) false)) false)) false))) false)))) false)) Case)))

(defun shen.t*-action (V3641 V3642 V3643 V3644 V3645) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V3077 (shen.lazyderef V3641 V3644) (if (cons? V3077) (let V3078 (shen.lazyderef (hd V3077) V3644) (if (= where V3078) (let V3079 (shen.lazyderef (tl V3077) V3644) (if (cons? V3079) (let P (hd V3079) (let V3080 (shen.lazyderef (tl V3079) V3644) (if (cons? V3080) (let Action (hd V3080) (let V3081 (shen.lazyderef (tl V3080) V3644) (if (= () V3081) (do (shen.incinfs) (cut Throwcontrol V3644 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V3643 V3644 (freeze (cut Throwcontrol V3644 (freeze (shen.t*-action Action V3642 (cons (cons P (cons : (cons verified ()))) V3643) V3644 V3645)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3082 (shen.lazyderef V3641 V3644) (if (cons? V3082) (let V3083 (shen.lazyderef (hd V3082) V3644) (if (= shen.choicepoint! V3083) (let V3084 (shen.lazyderef (tl V3082) V3644) (if (cons? V3084) (let V3085 (shen.lazyderef (hd V3084) V3644) (if (cons? V3085) (let V3086 (shen.lazyderef (hd V3085) V3644) (if (cons? V3086) (let V3087 (shen.lazyderef (hd V3086) V3644) (if (= fail-if V3087) (let V3088 (shen.lazyderef (tl V3086) V3644) (if (cons? V3088) (let F (hd V3088) (let V3089 (shen.lazyderef (tl V3088) V3644) (if (= () V3089) (let V3090 (shen.lazyderef (tl V3085) V3644) (if (cons? V3090) (let Action (hd V3090) (let V3091 (shen.lazyderef (tl V3090) V3644) (if (= () V3091) (let V3092 (shen.lazyderef (tl V3084) V3644) (if (= () V3092) (do (shen.incinfs) (cut Throwcontrol V3644 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V3642 V3643 V3644 V3645)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3093 (shen.lazyderef V3641 V3644) (if (cons? V3093) (let V3094 (shen.lazyderef (hd V3093) V3644) (if (= shen.choicepoint! V3094) (let V3095 (shen.lazyderef (tl V3093) V3644) (if (cons? V3095) (let Action (hd V3095) (let V3096 (shen.lazyderef (tl V3095) V3644) (if (= () V3096) (do (shen.incinfs) (cut Throwcontrol V3644 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V3642 V3643 V3644 V3645)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V3641 (cons : (cons V3642 ()))) V3643 V3644 V3645)) Case)) Case)) Case)))))

(defun findall (V3651 V3652 V3653 V3654 V3655) (let B (shen.newpv V3654) (let A (shen.newpv V3654) (do (shen.incinfs) (bind A (gensym shen.a) V3654 (freeze (bind B (set (shen.lazyderef A V3654) ()) V3654 (freeze (shen.findallhelp V3651 V3652 V3653 A V3654 V3655)))))))))

(defun shen.findallhelp (V3662 V3663 V3664 V3665 V3666 V3667) (let Case (do (shen.incinfs) (call V3663 V3666 (freeze (shen.remember V3665 V3662 V3666 (freeze (fwhen false V3666 V3667)))))) (if (= Case false) (do (shen.incinfs) (bind V3664 (value (shen.lazyderef V3665 V3666)) V3666 V3667)) Case)))

(defun shen.remember (V3672 V3673 V3674 V3675) (let B (shen.newpv V3674) (do (shen.incinfs) (bind B (set (shen.deref V3672 V3674) (cons (shen.deref V3673 V3674) (value (shen.deref V3672 V3674)))) V3674 V3675))))



