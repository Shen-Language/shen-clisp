"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen->kl (V1191 V1192) (compile (lambda X (shen.<define> X)) (cons V1191 V1192) (lambda X (shen-syntax-error V1191 X))))

(defun shen-syntax-error (V1199 V1200) (cond ((cons? V1200) (simple-error (cn "syntax error in " (shen.app V1199 (cn " here:

 " (shen.app (shen.next-50 50 (hd V1200)) "
" shen.a)) shen.a)))) (true (simple-error (cn "syntax error in " (shen.app V1199 "
" shen.a))))))

(defun shen.<define> (V1202) (let YaccParse (let Parse_shen.<name> (shen.<name> V1202) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<signature> (shen.<signature> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<name> (shen.<name> V1202) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) YaccParse)))

(defun shen.<name> (V1204) (if (cons? (hd V1204)) (let Parse_X (hd (hd V1204)) (shen.pair (hd (shen.pair (tl (hd V1204)) (shen.hdtl V1204))) (if (and (symbol? Parse_X) (not (shen.sysfunc? Parse_X))) Parse_X (simple-error (shen.app Parse_X " is not a legitimate function name.
" shen.a))))) (fail)))

(defun shen.sysfunc? (V1206) (element? V1206 (get (intern "shen") shen.external-symbols (value *property-vector*))))

(defun shen.<signature> (V1208) (if (and (cons? (hd V1208)) (= { (hd (hd V1208)))) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (tl (hd V1208)) (shen.hdtl V1208))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (and (cons? (hd Parse_shen.<signature-help>)) (= } (hd (hd Parse_shen.<signature-help>)))) (shen.pair (hd (shen.pair (tl (hd Parse_shen.<signature-help>)) (shen.hdtl Parse_shen.<signature-help>))) (shen.demodulate (shen.curry-type (shen.hdtl Parse_shen.<signature-help>)))) (fail)) (fail))) (fail)))

(defun shen.curry-type (V1210) (cond ((and (cons? V1210) (and (cons? (tl V1210)) (and (= --> (hd (tl V1210))) (and (cons? (tl (tl V1210))) (and (cons? (tl (tl (tl V1210)))) (= --> (hd (tl (tl (tl V1210)))))))))) (shen.curry-type (cons (hd V1210) (cons --> (cons (tl (tl V1210)) ()))))) ((and (cons? V1210) (and (cons? (tl V1210)) (and (= * (hd (tl V1210))) (and (cons? (tl (tl V1210))) (and (cons? (tl (tl (tl V1210)))) (= * (hd (tl (tl (tl V1210)))))))))) (shen.curry-type (cons (hd V1210) (cons * (cons (tl (tl V1210)) ()))))) ((cons? V1210) (map (lambda Z (shen.curry-type Z)) V1210)) (true V1210)))

(defun shen.<signature-help> (V1212) (let YaccParse (if (cons? (hd V1212)) (let Parse_X (hd (hd V1212)) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (tl (hd V1212)) (shen.hdtl V1212))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (not (element? Parse_X (cons { (cons } ())))) (shen.pair (hd Parse_shen.<signature-help>) (cons Parse_X (shen.hdtl Parse_shen.<signature-help>))) (fail)) (fail)))) (fail)) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1212) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<rules> (V1214) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V1214) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V1214) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) ())) (fail))) YaccParse)))

(defun shen.<rule> (V1216) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1216) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (hd (hd Parse_shen.<action>)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd Parse_shen.<action>)) (shen.hdtl Parse_shen.<action>))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<action>) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1216) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<action>) ()))) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1216) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (hd (hd Parse_shen.<action>)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd Parse_shen.<action>)) (shen.hdtl Parse_shen.<action>))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<patterns> (shen.<patterns> V1216) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) (fail))) (fail)) (fail))) YaccParse)) YaccParse)) YaccParse)))

(defun shen.fail_if (V1219 V1220) (if (V1219 V1220) (fail) V1220))

(defun shen.succeeds? (V1226) (cond ((= V1226 (fail)) false) (true true)))

(defun shen.<patterns> (V1228) (let YaccParse (let Parse_shen.<pattern> (shen.<pattern> V1228) (if (not (= (fail) Parse_shen.<pattern>)) (let Parse_shen.<patterns> (shen.<patterns> Parse_shen.<pattern>) (if (not (= (fail) Parse_shen.<patterns>)) (shen.pair (hd Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<pattern>) (shen.hdtl Parse_shen.<patterns>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1228) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<pattern> (V1235) (let YaccParse (if (and (cons? (hd V1235)) (cons? (hd (hd V1235)))) (if (and (cons? (hd (shen.pair (hd (hd V1235)) (hd (tl V1235))))) (= @p (hd (hd (shen.pair (hd (hd V1235)) (hd (tl V1235))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1235)) (hd (tl V1235))))) (shen.hdtl (shen.pair (hd (hd V1235)) (hd (tl V1235)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1235)) (hd (tl V1235)))) (cons @p (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1235)) (cons? (hd (hd V1235)))) (if (and (cons? (hd (shen.pair (hd (hd V1235)) (hd (tl V1235))))) (= cons (hd (hd (shen.pair (hd (hd V1235)) (hd (tl V1235))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1235)) (hd (tl V1235))))) (shen.hdtl (shen.pair (hd (hd V1235)) (hd (tl V1235)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1235)) (hd (tl V1235)))) (cons cons (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1235)) (cons? (hd (hd V1235)))) (if (and (cons? (hd (shen.pair (hd (hd V1235)) (hd (tl V1235))))) (= @v (hd (hd (shen.pair (hd (hd V1235)) (hd (tl V1235))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1235)) (hd (tl V1235))))) (shen.hdtl (shen.pair (hd (hd V1235)) (hd (tl V1235)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1235)) (hd (tl V1235)))) (cons @v (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1235)) (cons? (hd (hd V1235)))) (if (and (cons? (hd (shen.pair (hd (hd V1235)) (hd (tl V1235))))) (= @s (hd (hd (shen.pair (hd (hd V1235)) (hd (tl V1235))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1235)) (hd (tl V1235))))) (shen.hdtl (shen.pair (hd (hd V1235)) (hd (tl V1235)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1235)) (hd (tl V1235)))) (cons @s (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1235)) (cons? (hd (hd V1235)))) (if (and (cons? (hd (shen.pair (hd (hd V1235)) (hd (tl V1235))))) (= vector (hd (hd (shen.pair (hd (hd V1235)) (hd (tl V1235))))))) (if (and (cons? (hd (shen.pair (tl (hd (shen.pair (hd (hd V1235)) (hd (tl V1235))))) (shen.hdtl (shen.pair (hd (hd V1235)) (hd (tl V1235))))))) (= 0 (hd (hd (shen.pair (tl (hd (shen.pair (hd (hd V1235)) (hd (tl V1235))))) (shen.hdtl (shen.pair (hd (hd V1235)) (hd (tl V1235))))))))) (shen.pair (hd (shen.pair (tl (hd V1235)) (hd (tl V1235)))) (cons vector (cons 0 ()))) (fail)) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (cons? (hd V1235)) (let Parse_X (hd (hd V1235)) (if (cons? Parse_X) (shen.pair (hd (shen.pair (tl (hd V1235)) (shen.hdtl V1235))) (shen.constructor-error Parse_X)) (fail))) (fail)) (if (= YaccParse (fail)) (let Parse_shen.<simple_pattern> (shen.<simple_pattern> V1235) (if (not (= (fail) Parse_shen.<simple_pattern>)) (shen.pair (hd Parse_shen.<simple_pattern>) (shen.hdtl Parse_shen.<simple_pattern>)) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.constructor-error (V1237) (simple-error (shen.app V1237 " is not a legitimate constructor
" shen.a)))

(defun shen.<simple_pattern> (V1239) (let YaccParse (if (cons? (hd V1239)) (let Parse_X (hd (hd V1239)) (if (= Parse_X _) (shen.pair (hd (shen.pair (tl (hd V1239)) (shen.hdtl V1239))) (gensym Parse_Y)) (fail))) (fail)) (if (= YaccParse (fail)) (if (cons? (hd V1239)) (let Parse_X (hd (hd V1239)) (if (not (element? Parse_X (cons -> (cons <- ())))) (shen.pair (hd (shen.pair (tl (hd V1239)) (shen.hdtl V1239))) Parse_X) (fail))) (fail)) YaccParse)))

(defun shen.<pattern1> (V1241) (let Parse_shen.<pattern> (shen.<pattern> V1241) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<pattern2> (V1243) (let Parse_shen.<pattern> (shen.<pattern> V1243) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<action> (V1245) (if (cons? (hd V1245)) (let Parse_X (hd (hd V1245)) (shen.pair (hd (shen.pair (tl (hd V1245)) (shen.hdtl V1245))) Parse_X)) (fail)))

(defun shen.<guard> (V1247) (if (cons? (hd V1247)) (let Parse_X (hd (hd V1247)) (shen.pair (hd (shen.pair (tl (hd V1247)) (shen.hdtl V1247))) Parse_X)) (fail)))

(defun shen.compile_to_machine_code (V1250 V1251) (let Lambda+ (shen.compile_to_lambda+ V1250 V1251) (let KL (shen.compile_to_kl V1250 Lambda+) (let Record (shen.record-source V1250 KL) KL))))

(defun shen.record-source (V1256 V1257) (cond ((value shen.*installing-kl*) shen.skip) (true (put V1256 shen.source V1257 (value *property-vector*)))))

(defun shen.compile_to_lambda+ (V1260 V1261) (let Arity (shen.aritycheck V1260 V1261) (let UpDateSymbolTable (shen.update-symbol-table V1260 Arity) (let Free (map (lambda Rule (shen.free_variable_check V1260 Rule)) V1261) (let Variables (shen.parameters Arity) (let Strip (map (lambda X (shen.strip-protect X)) V1261) (let Abstractions (map (lambda X (shen.abstract_rule X)) Strip) (let Applications (map (lambda X (shen.application_build Variables X)) Abstractions) (cons Variables (cons Applications ()))))))))))

(defun shen.update-symbol-table (V1264 V1265) (set shen.*symbol-table* (shen.update-symbol-table-h V1264 V1265 (value shen.*symbol-table*) ())))

(defun shen.update-symbol-table-h (V1273 V1274 V1275 V1276) (cond ((= () V1275) (let NewEntry (cons V1273 (eval-kl (shen.lambda-form V1273 V1274))) (cons NewEntry V1276))) ((and (cons? V1275) (and (cons? (hd V1275)) (= (hd (hd V1275)) V1273))) (let ChangedEntry (cons (hd (hd V1275)) (eval-kl (shen.lambda-form (hd (hd V1275)) V1274))) (append (tl V1275) (cons ChangedEntry V1276)))) ((cons? V1275) (shen.update-symbol-table-h V1273 V1274 (tl V1275) (cons (hd V1275) V1276))) (true (shen.f_error shen.update-symbol-table-h))))

(defun shen.free_variable_check (V1279 V1280) (cond ((and (cons? V1280) (and (cons? (tl V1280)) (= () (tl (tl V1280))))) (let Bound (shen.extract_vars (hd V1280)) (let Free (shen.extract_free_vars Bound (hd (tl V1280))) (shen.free_variable_warnings V1279 Free)))) (true (shen.f_error shen.free_variable_check))))

(defun shen.extract_vars (V1282) (cond ((variable? V1282) (cons V1282 ())) ((cons? V1282) (union (shen.extract_vars (hd V1282)) (shen.extract_vars (tl V1282)))) (true ())))

(defun shen.extract_free_vars (V1294 V1295) (cond ((and (cons? V1295) (and (cons? (tl V1295)) (and (= () (tl (tl V1295))) (= (hd V1295) protect)))) ()) ((and (variable? V1295) (not (element? V1295 V1294))) (cons V1295 ())) ((and (cons? V1295) (and (= lambda (hd V1295)) (and (cons? (tl V1295)) (and (cons? (tl (tl V1295))) (= () (tl (tl (tl V1295)))))))) (shen.extract_free_vars (cons (hd (tl V1295)) V1294) (hd (tl (tl V1295))))) ((and (cons? V1295) (and (= let (hd V1295)) (and (cons? (tl V1295)) (and (cons? (tl (tl V1295))) (and (cons? (tl (tl (tl V1295)))) (= () (tl (tl (tl (tl V1295)))))))))) (union (shen.extract_free_vars V1294 (hd (tl (tl V1295)))) (shen.extract_free_vars (cons (hd (tl V1295)) V1294) (hd (tl (tl (tl V1295))))))) ((cons? V1295) (union (shen.extract_free_vars V1294 (hd V1295)) (shen.extract_free_vars V1294 (tl V1295)))) (true ())))

(defun shen.free_variable_warnings (V1300 V1301) (cond ((= () V1301) _) (true (simple-error (cn "error: the following variables are free in " (shen.app V1300 (cn ": " (shen.app (shen.list_variables V1301) "" shen.a)) shen.a))))))

(defun shen.list_variables (V1303) (cond ((and (cons? V1303) (= () (tl V1303))) (cn (str (hd V1303)) ".")) ((cons? V1303) (cn (str (hd V1303)) (cn ", " (shen.list_variables (tl V1303))))) (true (shen.f_error shen.list_variables))))

(defun shen.strip-protect (V1305) (cond ((and (cons? V1305) (and (cons? (tl V1305)) (and (= () (tl (tl V1305))) (= (hd V1305) protect)))) (shen.strip-protect (hd (tl V1305)))) ((cons? V1305) (map (lambda Z (shen.strip-protect Z)) V1305)) (true V1305)))

(defun shen.linearise (V1307) (cond ((and (cons? V1307) (and (cons? (tl V1307)) (= () (tl (tl V1307))))) (shen.linearise_help (shen.flatten (hd V1307)) (hd V1307) (hd (tl V1307)))) (true (shen.f_error shen.linearise))))

(defun shen.flatten (V1309) (cond ((= () V1309) ()) ((cons? V1309) (append (shen.flatten (hd V1309)) (shen.flatten (tl V1309)))) (true (cons V1309 ()))))

(defun shen.linearise_help (V1313 V1314 V1315) (cond ((= () V1313) (cons V1314 (cons V1315 ()))) ((cons? V1313) (if (and (variable? (hd V1313)) (element? (hd V1313) (tl V1313))) (let Var (gensym (hd V1313)) (let NewAction (cons where (cons (cons = (cons (hd V1313) (cons Var ()))) (cons V1315 ()))) (let NewPatts (shen.linearise_X (hd V1313) Var V1314) (shen.linearise_help (tl V1313) NewPatts NewAction)))) (shen.linearise_help (tl V1313) V1314 V1315))) (true (shen.f_error shen.linearise_help))))

(defun shen.linearise_X (V1328 V1329 V1330) (cond ((= V1330 V1328) V1329) ((cons? V1330) (let L (shen.linearise_X V1328 V1329 (hd V1330)) (if (= L (hd V1330)) (cons (hd V1330) (shen.linearise_X V1328 V1329 (tl V1330))) (cons L (tl V1330))))) (true V1330)))

(defun shen.aritycheck (V1333 V1334) (cond ((and (cons? V1334) (and (cons? (hd V1334)) (and (cons? (tl (hd V1334))) (and (= () (tl (tl (hd V1334)))) (= () (tl V1334)))))) (do (shen.aritycheck-action (hd (tl (hd V1334)))) (shen.aritycheck-name V1333 (arity V1333) (length (hd (hd V1334)))))) ((and (cons? V1334) (and (cons? (hd V1334)) (and (cons? (tl (hd V1334))) (and (= () (tl (tl (hd V1334)))) (and (cons? (tl V1334)) (and (cons? (hd (tl V1334))) (and (cons? (tl (hd (tl V1334)))) (= () (tl (tl (hd (tl V1334)))))))))))) (if (= (length (hd (hd V1334))) (length (hd (hd (tl V1334))))) (do (shen.aritycheck-action (hd (tl (hd V1334)))) (shen.aritycheck V1333 (tl V1334))) (simple-error (cn "arity error in " (shen.app V1333 "
" shen.a))))) (true (shen.f_error shen.aritycheck))))

(defun shen.aritycheck-name (V1347 V1348 V1349) (cond ((= -1 V1348) V1349) ((= V1349 V1348) V1349) (true (do (shen.prhush (cn "
warning: changing the arity of " (shen.app V1347 " can cause errors.
" shen.a)) (stoutput)) V1349))))

(defun shen.aritycheck-action (V1355) (cond ((cons? V1355) (do (shen.aah (hd V1355) (tl V1355)) (map (lambda Y (shen.aritycheck-action Y)) V1355))) (true shen.skip)))

(defun shen.aah (V1358 V1359) (let Arity (arity V1358) (let Len (length V1359) (if (and (> Arity -1) (> Len Arity)) (shen.prhush (cn "warning: " (shen.app V1358 (cn " might not like " (shen.app Len (cn " argument" (shen.app (if (> Len 1) "s" "") ".
" shen.a)) shen.a)) shen.a)) (stoutput)) shen.skip))))

(defun shen.abstract_rule (V1361) (cond ((and (cons? V1361) (and (cons? (tl V1361)) (= () (tl (tl V1361))))) (shen.abstraction_build (hd V1361) (hd (tl V1361)))) (true (shen.f_error shen.abstract_rule))))

(defun shen.abstraction_build (V1364 V1365) (cond ((= () V1364) V1365) ((cons? V1364) (cons /. (cons (hd V1364) (cons (shen.abstraction_build (tl V1364) V1365) ())))) (true (shen.f_error shen.abstraction_build))))

(defun shen.parameters (V1367) (cond ((= 0 V1367) ()) (true (cons (gensym V) (shen.parameters (- V1367 1))))))

(defun shen.application_build (V1370 V1371) (cond ((= () V1370) V1371) ((cons? V1370) (shen.application_build (tl V1370) (cons V1371 (cons (hd V1370) ())))) (true (shen.f_error shen.application_build))))

(defun shen.compile_to_kl (V1374 V1375) (cond ((and (cons? V1375) (and (cons? (tl V1375)) (= () (tl (tl V1375))))) (let Arity (shen.store-arity V1374 (length (hd V1375))) (let Reduce (map (lambda X (shen.reduce X)) (hd (tl V1375))) (let CondExpression (shen.cond-expression V1374 (hd V1375) Reduce) (let TypeTable (if (value shen.*optimise*) (shen.typextable (shen.get-type V1374) (hd V1375)) shen.skip) (let TypedCondExpression (if (value shen.*optimise*) (shen.assign-types (hd V1375) TypeTable CondExpression) CondExpression) (cons defun (cons V1374 (cons (hd V1375) (cons TypedCondExpression ())))))))))) (true (shen.f_error shen.compile_to_kl))))

(defun shen.get-type (V1381) (cond ((cons? V1381) shen.skip) (true (let FType (assoc V1381 (value shen.*signedfuncs*)) (if (empty? FType) shen.skip (tl FType))))))

(defun shen.typextable (V1392 V1393) (cond ((and (cons? V1392) (and (cons? (tl V1392)) (and (= --> (hd (tl V1392))) (and (cons? (tl (tl V1392))) (and (= () (tl (tl (tl V1392)))) (cons? V1393)))))) (if (variable? (hd V1392)) (shen.typextable (hd (tl (tl V1392))) (tl V1393)) (cons (cons (hd V1393) (hd V1392)) (shen.typextable (hd (tl (tl V1392))) (tl V1393))))) (true ())))

(defun shen.assign-types (V1397 V1398 V1399) (cond ((and (cons? V1399) (and (= let (hd V1399)) (and (cons? (tl V1399)) (and (cons? (tl (tl V1399))) (and (cons? (tl (tl (tl V1399)))) (= () (tl (tl (tl (tl V1399)))))))))) (cons let (cons (hd (tl V1399)) (cons (shen.assign-types V1397 V1398 (hd (tl (tl V1399)))) (cons (shen.assign-types (cons (hd (tl V1399)) V1397) V1398 (hd (tl (tl (tl V1399))))) ()))))) ((and (cons? V1399) (and (= lambda (hd V1399)) (and (cons? (tl V1399)) (and (cons? (tl (tl V1399))) (= () (tl (tl (tl V1399)))))))) (cons lambda (cons (hd (tl V1399)) (cons (shen.assign-types (cons (hd (tl V1399)) V1397) V1398 (hd (tl (tl V1399)))) ())))) ((and (cons? V1399) (= cond (hd V1399))) (cons cond (map (lambda Y (cons (shen.assign-types V1397 V1398 (hd Y)) (cons (shen.assign-types V1397 V1398 (hd (tl Y))) ()))) (tl V1399)))) ((cons? V1399) (let NewTable (shen.typextable (shen.get-type (hd V1399)) (tl V1399)) (cons (hd V1399) (map (lambda Y (shen.assign-types V1397 (append V1398 NewTable) Y)) (tl V1399))))) (true (let AtomType (assoc V1399 V1398) (if (cons? AtomType) (cons type (cons V1399 (cons (tl AtomType) ()))) (if (element? V1399 V1397) V1399 (shen.atom-type V1399)))))))

(defun shen.atom-type (V1401) (if (string? V1401) (cons type (cons V1401 (cons string ()))) (if (number? V1401) (cons type (cons V1401 (cons number ()))) (if (boolean? V1401) (cons type (cons V1401 (cons boolean ()))) (if (symbol? V1401) (cons type (cons V1401 (cons symbol ()))) V1401)))))

(defun shen.store-arity (V1406 V1407) (cond ((value shen.*installing-kl*) shen.skip) (true (put V1406 arity V1407 (value *property-vector*)))))

(defun shen.reduce (V1409) (do (set shen.*teststack* ()) (let Result (shen.reduce_help V1409) (cons (cons : (cons shen.tests (reverse (value shen.*teststack*)))) (cons Result ())))))

(defun shen.reduce_help (V1411) (cond ((and (cons? V1411) (and (cons? (hd V1411)) (and (= /. (hd (hd V1411))) (and (cons? (tl (hd V1411))) (and (cons? (hd (tl (hd V1411)))) (and (= cons (hd (hd (tl (hd V1411))))) (and (cons? (tl (hd (tl (hd V1411))))) (and (cons? (tl (tl (hd (tl (hd V1411)))))) (and (= () (tl (tl (tl (hd (tl (hd V1411))))))) (and (cons? (tl (tl (hd V1411)))) (and (= () (tl (tl (tl (hd V1411))))) (and (cons? (tl V1411)) (= () (tl (tl V1411))))))))))))))) (do (shen.add_test (cons cons? (tl V1411))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1411))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1411)))))) (cons (shen.ebr (hd (tl V1411)) (hd (tl (hd V1411))) (hd (tl (tl (hd V1411))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hd (tl V1411)) ())) (cons (cons tl (tl V1411)) ())) (shen.reduce_help Application))))) ((and (cons? V1411) (and (cons? (hd V1411)) (and (= /. (hd (hd V1411))) (and (cons? (tl (hd V1411))) (and (cons? (hd (tl (hd V1411)))) (and (= @p (hd (hd (tl (hd V1411))))) (and (cons? (tl (hd (tl (hd V1411))))) (and (cons? (tl (tl (hd (tl (hd V1411)))))) (and (= () (tl (tl (tl (hd (tl (hd V1411))))))) (and (cons? (tl (tl (hd V1411)))) (and (= () (tl (tl (tl (hd V1411))))) (and (cons? (tl V1411)) (= () (tl (tl V1411))))))))))))))) (do (shen.add_test (cons tuple? (tl V1411))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1411))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1411)))))) (cons (shen.ebr (hd (tl V1411)) (hd (tl (hd V1411))) (hd (tl (tl (hd V1411))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons fst (tl V1411)) ())) (cons (cons snd (tl V1411)) ())) (shen.reduce_help Application))))) ((and (cons? V1411) (and (cons? (hd V1411)) (and (= /. (hd (hd V1411))) (and (cons? (tl (hd V1411))) (and (cons? (hd (tl (hd V1411)))) (and (= @v (hd (hd (tl (hd V1411))))) (and (cons? (tl (hd (tl (hd V1411))))) (and (cons? (tl (tl (hd (tl (hd V1411)))))) (and (= () (tl (tl (tl (hd (tl (hd V1411))))))) (and (cons? (tl (tl (hd V1411)))) (and (= () (tl (tl (tl (hd V1411))))) (and (cons? (tl V1411)) (= () (tl (tl V1411))))))))))))))) (do (shen.add_test (cons shen.+vector? (tl V1411))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1411))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1411)))))) (cons (shen.ebr (hd (tl V1411)) (hd (tl (hd V1411))) (hd (tl (tl (hd V1411))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hdv (tl V1411)) ())) (cons (cons tlv (tl V1411)) ())) (shen.reduce_help Application))))) ((and (cons? V1411) (and (cons? (hd V1411)) (and (= /. (hd (hd V1411))) (and (cons? (tl (hd V1411))) (and (cons? (hd (tl (hd V1411)))) (and (= @s (hd (hd (tl (hd V1411))))) (and (cons? (tl (hd (tl (hd V1411))))) (and (cons? (tl (tl (hd (tl (hd V1411)))))) (and (= () (tl (tl (tl (hd (tl (hd V1411))))))) (and (cons? (tl (tl (hd V1411)))) (and (= () (tl (tl (tl (hd V1411))))) (and (cons? (tl V1411)) (= () (tl (tl V1411))))))))))))))) (do (shen.add_test (cons shen.+string? (tl V1411))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1411))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1411)))))) (cons (shen.ebr (hd (tl V1411)) (hd (tl (hd V1411))) (hd (tl (tl (hd V1411))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons pos (cons (hd (tl V1411)) (cons 0 ()))) ())) (cons (cons tlstr (tl V1411)) ())) (shen.reduce_help Application))))) ((and (cons? V1411) (and (cons? (hd V1411)) (and (= /. (hd (hd V1411))) (and (cons? (tl (hd V1411))) (and (cons? (tl (tl (hd V1411)))) (and (= () (tl (tl (tl (hd V1411))))) (and (cons? (tl V1411)) (and (= () (tl (tl V1411))) (not (variable? (hd (tl (hd V1411))))))))))))) (do (shen.add_test (cons = (cons (hd (tl (hd V1411))) (tl V1411)))) (shen.reduce_help (hd (tl (tl (hd V1411))))))) ((and (cons? V1411) (and (cons? (hd V1411)) (and (= /. (hd (hd V1411))) (and (cons? (tl (hd V1411))) (and (cons? (tl (tl (hd V1411)))) (and (= () (tl (tl (tl (hd V1411))))) (and (cons? (tl V1411)) (= () (tl (tl V1411)))))))))) (shen.reduce_help (shen.ebr (hd (tl V1411)) (hd (tl (hd V1411))) (hd (tl (tl (hd V1411))))))) ((and (cons? V1411) (and (= where (hd V1411)) (and (cons? (tl V1411)) (and (cons? (tl (tl V1411))) (= () (tl (tl (tl V1411)))))))) (do (shen.add_test (hd (tl V1411))) (shen.reduce_help (hd (tl (tl V1411)))))) ((and (cons? V1411) (and (cons? (tl V1411)) (= () (tl (tl V1411))))) (let Z (shen.reduce_help (hd V1411)) (if (= (hd V1411) Z) V1411 (shen.reduce_help (cons Z (tl V1411)))))) (true V1411)))

(defun shen.+string? (V1413) (cond ((= "" V1413) false) (true (string? V1413))))

(defun shen.+vector (V1415) (cond ((= V1415 (vector 0)) false) (true (vector? V1415))))

(defun shen.ebr (V1429 V1430 V1431) (cond ((= V1431 V1430) V1429) ((and (cons? V1431) (and (= /. (hd V1431)) (and (cons? (tl V1431)) (and (cons? (tl (tl V1431))) (and (= () (tl (tl (tl V1431)))) (> (occurrences V1430 (hd (tl V1431))) 0)))))) V1431) ((and (cons? V1431) (and (= lambda (hd V1431)) (and (cons? (tl V1431)) (and (cons? (tl (tl V1431))) (and (= () (tl (tl (tl V1431)))) (> (occurrences V1430 (hd (tl V1431))) 0)))))) V1431) ((and (cons? V1431) (and (= let (hd V1431)) (and (cons? (tl V1431)) (and (cons? (tl (tl V1431))) (and (cons? (tl (tl (tl V1431)))) (and (= () (tl (tl (tl (tl V1431))))) (= (hd (tl V1431)) V1430))))))) (cons let (cons (hd (tl V1431)) (cons (shen.ebr V1429 (hd (tl V1431)) (hd (tl (tl V1431)))) (tl (tl (tl V1431))))))) ((cons? V1431) (cons (shen.ebr V1429 V1430 (hd V1431)) (shen.ebr V1429 V1430 (tl V1431)))) (true V1431)))

(defun shen.add_test (V1433) (set shen.*teststack* (cons V1433 (value shen.*teststack*))))

(defun shen.cond-expression (V1437 V1438 V1439) (let Err (shen.err-condition V1437) (let Cases (shen.case-form V1439 Err) (let EncodeChoices (shen.encode-choices Cases V1437) (shen.cond-form EncodeChoices)))))

(defun shen.cond-form (V1443) (cond ((and (cons? V1443) (and (cons? (hd V1443)) (and (= true (hd (hd V1443))) (and (cons? (tl (hd V1443))) (= () (tl (tl (hd V1443)))))))) (hd (tl (hd V1443)))) (true (cons cond V1443))))

(defun shen.encode-choices (V1448 V1449) (cond ((= () V1448) ()) ((and (cons? V1448) (and (cons? (hd V1448)) (and (= true (hd (hd V1448))) (and (cons? (tl (hd V1448))) (and (cons? (hd (tl (hd V1448)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1448))))) (and (cons? (tl (hd (tl (hd V1448))))) (and (= () (tl (tl (hd (tl (hd V1448)))))) (and (= () (tl (tl (hd V1448)))) (= () (tl V1448))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1448))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (if (value shen.*installing-kl*) (cons shen.sys-error (cons V1449 ())) (cons shen.f_error (cons V1449 ()))) (cons Result ())))) ())))) ())) ())) ((and (cons? V1448) (and (cons? (hd V1448)) (and (= true (hd (hd V1448))) (and (cons? (tl (hd V1448))) (and (cons? (hd (tl (hd V1448)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1448))))) (and (cons? (tl (hd (tl (hd V1448))))) (and (= () (tl (tl (hd (tl (hd V1448)))))) (= () (tl (tl (hd V1448)))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1448))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (shen.cond-form (shen.encode-choices (tl V1448) V1449)) (cons Result ())))) ())))) ())) ())) ((and (cons? V1448) (and (cons? (hd V1448)) (and (cons? (tl (hd V1448))) (and (cons? (hd (tl (hd V1448)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1448))))) (and (cons? (tl (hd (tl (hd V1448))))) (and (= () (tl (tl (hd (tl (hd V1448)))))) (= () (tl (tl (hd V1448))))))))))) (cons (cons true (cons (cons let (cons Freeze (cons (cons freeze (cons (shen.cond-form (shen.encode-choices (tl V1448) V1449)) ())) (cons (cons if (cons (hd (hd V1448)) (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1448))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (cons thaw (cons Freeze ())) (cons Result ())))) ())))) (cons (cons thaw (cons Freeze ())) ())))) ())))) ())) ())) ((and (cons? V1448) (and (cons? (hd V1448)) (and (cons? (tl (hd V1448))) (= () (tl (tl (hd V1448))))))) (cons (hd V1448) (shen.encode-choices (tl V1448) V1449))) (true (shen.f_error shen.encode-choices))))

(defun shen.case-form (V1456 V1457) (cond ((= () V1456) (cons V1457 ())) ((and (cons? V1456) (and (cons? (hd V1456)) (and (cons? (hd (hd V1456))) (and (= : (hd (hd (hd V1456)))) (and (cons? (tl (hd (hd V1456)))) (and (= shen.tests (hd (tl (hd (hd V1456))))) (and (= () (tl (tl (hd (hd V1456))))) (and (cons? (tl (hd V1456))) (and (cons? (hd (tl (hd V1456)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1456))))) (and (cons? (tl (hd (tl (hd V1456))))) (and (= () (tl (tl (hd (tl (hd V1456)))))) (= () (tl (tl (hd V1456)))))))))))))))) (cons (cons true (tl (hd V1456))) (shen.case-form (tl V1456) V1457))) ((and (cons? V1456) (and (cons? (hd V1456)) (and (cons? (hd (hd V1456))) (and (= : (hd (hd (hd V1456)))) (and (cons? (tl (hd (hd V1456)))) (and (= shen.tests (hd (tl (hd (hd V1456))))) (and (= () (tl (tl (hd (hd V1456))))) (and (cons? (tl (hd V1456))) (= () (tl (tl (hd V1456)))))))))))) (cons (cons true (tl (hd V1456))) ())) ((and (cons? V1456) (and (cons? (hd V1456)) (and (cons? (hd (hd V1456))) (and (= : (hd (hd (hd V1456)))) (and (cons? (tl (hd (hd V1456)))) (and (= shen.tests (hd (tl (hd (hd V1456))))) (and (cons? (tl (hd V1456))) (= () (tl (tl (hd V1456))))))))))) (cons (cons (shen.embed-and (tl (tl (hd (hd V1456))))) (tl (hd V1456))) (shen.case-form (tl V1456) V1457))) (true (shen.f_error shen.case-form))))

(defun shen.embed-and (V1459) (cond ((and (cons? V1459) (= () (tl V1459))) (hd V1459)) ((cons? V1459) (cons and (cons (hd V1459) (cons (shen.embed-and (tl V1459)) ())))) (true (shen.f_error shen.embed-and))))

(defun shen.err-condition (V1461) (cons true (cons (cons shen.f_error (cons V1461 ())) ())))

(defun shen.sys-error (V1463) (simple-error (cn "system function " (shen.app V1463 ": unexpected argument
" shen.a))))



